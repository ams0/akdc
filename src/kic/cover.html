
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>boa: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kic/boa/boa.go (1.5%)</option>
				
				<option value="file1">kic/boa/boaExecCmd.go (0.0%)</option>
				
				<option value="file2">kic/boa/cfmt/cfmt.go (58.6%)</option>
				
				<option value="file3">kic/boa/io.go (60.4%)</option>
				
				<option value="file4">kic/boa/shell.go (87.5%)</option>
				
				<option value="file5">kic/cmd/fleet/az.go (100.0%)</option>
				
				<option value="file6">kic/cmd/fleet/check.go (53.8%)</option>
				
				<option value="file7">kic/cmd/fleet/create.go (17.8%)</option>
				
				<option value="file8">kic/cmd/fleet/delete.go (0.0%)</option>
				
				<option value="file9">kic/cmd/fleet/dns.go (100.0%)</option>
				
				<option value="file10">kic/cmd/fleet/exec.go (83.3%)</option>
				
				<option value="file11">kic/cmd/fleet/fleet.go (100.0%)</option>
				
				<option value="file12">kic/cmd/fleet/list.go (46.7%)</option>
				
				<option value="file13">kic/cmd/fleet/new-app.go (100.0%)</option>
				
				<option value="file14">kic/cmd/fleet/ssh.go (0.0%)</option>
				
				<option value="file15">kic/cmd/kic/build.go (100.0%)</option>
				
				<option value="file16">kic/cmd/kic/check.go (100.0%)</option>
				
				<option value="file17">kic/cmd/kic/cluster.go (100.0%)</option>
				
				<option value="file18">kic/cmd/kic/kic.go (100.0%)</option>
				
				<option value="file19">kic/cmd/kivm/check.go (89.5%)</option>
				
				<option value="file20">kic/cmd/kivm/cluster.go (100.0%)</option>
				
				<option value="file21">kic/cmd/kivm/kivm.go (100.0%)</option>
				
				<option value="file22">kic/cmd/kubekic/build.go (100.0%)</option>
				
				<option value="file23">kic/cmd/kubekic/check.go (100.0%)</option>
				
				<option value="file24">kic/cmd/kubekic/cluster.go (66.7%)</option>
				
				<option value="file25">kic/cmd/kubekic/kic.go (90.9%)</option>
				
				<option value="file26">kic/cmd/root.go (35.3%)</option>
				
				<option value="file27">kic/cmd/targets/targets-add.go (88.9%)</option>
				
				<option value="file28">kic/cmd/targets/targets-clear.go (87.5%)</option>
				
				<option value="file29">kic/cmd/targets/targets-deploy.go (0.0%)</option>
				
				<option value="file30">kic/cmd/targets/targets-list.go (75.0%)</option>
				
				<option value="file31">kic/cmd/targets/targets-remove.go (76.5%)</option>
				
				<option value="file32">kic/cmd/targets/targets.go (75.8%)</option>
				
				<option value="file33">kic/cmd/test/test-integration.go (10.7%)</option>
				
				<option value="file34">kic/cmd/test/test-load.go (89.3%)</option>
				
				<option value="file35">kic/cmd/test/test.go (100.0%)</option>
				
				<option value="file36">kic/main.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "fmt"
        "io/ioutil"
        "kic/boa/cfmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
)

var boaPath string
var boaCommandPath string

var boaRootCmd *cobra.Command

// load commands from *.boa
// commands are in the .binName directory
//    that is a subdirectory of where the bin file is located
// example: /bin/.kic
func LoadCommands(appRootCmd *cobra.Command) <span class="cov0" title="0">{
        // set boaRootCmd to the app root command
        boaRootCmd = appRootCmd

        boaPath = GetBoaPath()
        boaCommandPath = GetBoaCommandPath()

        // load boaPath/*.boa
        files, err := ioutil.ReadDir(boaPath)
        if err == nil </span><span class="cov0" title="0">{
                for _, f := range files </span><span class="cov0" title="0">{
                        if !f.IsDir() &amp;&amp; strings.HasSuffix(strings.ToLower(f.Name()), ".boa") </span><span class="cov0" title="0">{
                                loadCommand(f.Name())
                        }</span>
                }
        }
}

// get a command by Use (Name)
func GetCommandByUse(cmd *cobra.Command, use string) *cobra.Command <span class="cov8" title="1">{
        if cmd != nil &amp;&amp; len(cmd.Commands()) &gt; 0 </span><span class="cov8" title="1">{
                for _, c := range cmd.Commands() </span><span class="cov8" title="1">{
                        if c.Use == use </span><span class="cov8" title="1">{
                                return c
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// reset cmdRoot to new__root command if set
// otherwise remove any hidden root commands
func SetNewRoot() *cobra.Command <span class="cov0" title="0">{
        var cmd *cobra.Command

        // create a new root command
        // todo - this causes an error
        cmd = &amp;cobra.Command{Use: boaRootCmd.Use, Short: boaRootCmd.Short, Long: boaRootCmd.Long}

        // check for new__root
        nr := GetCommandByUse(boaRootCmd, "new__root")

        if nr == nil </span><span class="cov0" title="0">{
                // add all non-hidden commands to the new root
                for _, c := range boaRootCmd.Commands() </span><span class="cov0" title="0">{
                        if !c.Hidden </span><span class="cov0" title="0">{
                                cmd.AddCommand(c)
                        }</span>
                        <span class="cov0" title="0">boaRootCmd = cmd</span>
                }
        } else<span class="cov0" title="0"> {
                // get the new root
                cmd = GetCommandByUse(boaRootCmd, nr.Short)

                if cmd == nil </span><span class="cov0" title="0">{
                        // new__root not found
                        cfmt.ErrorE("New root command not found", nr.Short)
                        os.Exit(1)
                }</span>

                // create the new boaRootCmd
                // we have to do this as the parent is set to the existing boaRootCmd
                <span class="cov0" title="0">nr = &amp;cobra.Command{Use: boaRootCmd.Use, Short: cmd.Short, Long: cmd.Long}

                for _, c := range cmd.Commands() </span><span class="cov0" title="0">{
                        // add all commands that aren't hidden
                        if !c.Hidden </span><span class="cov0" title="0">{
                                nr.AddCommand(c)
                        }</span>
                }
                <span class="cov0" title="0">boaRootCmd = nr</span>
        }

        <span class="cov0" title="0">return boaRootCmd</span>
}

// return the stop word for file reads
func getStopWord(line string) string <span class="cov0" title="0">{

        chk := strings.ToLower(line)

        if strings.HasPrefix(chk, "root") </span><span class="cov0" title="0">{
                return "root"
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(chk, "command") </span><span class="cov0" title="0">{
                return "command"
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(chk, "runcommand") </span><span class="cov0" title="0">{
                return "runCommand"
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(chk, "boacommand") </span><span class="cov0" title="0">{
                return "boaCommand"
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(chk, "fltcommand") </span><span class="cov0" title="0">{
                return "fltCommand"
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(chk, "popcommand") </span><span class="cov0" title="0">{
                return "popCommand"
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// load command(s) from a file
func loadCommand(fileName string) <span class="cov0" title="0">{
        var boaCmd *cobra.Command

        // todo - convert to struct
        var modType string
        var name string
        var short string
        var long string
        var path string
        var parent string
        var hidden bool

        // read file into an array
        lines := ReadLinesFromFile(filepath.Join(boaPath, fileName))

        for i := 0; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                line := strings.TrimSpace(lines[i])
                line = strings.Replace(line, "\\n", "\n", -1)

                // ignore comments
                if !strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        chk := strings.ToLower(line)

                        // check for stop word
                        sw := getStopWord(chk)
                        if sw != "" </span><span class="cov0" title="0">{
                                if strings.HasPrefix(sw, "popCommand") </span><span class="cov0" title="0">{
                                        // popCommand resets the command to the parent or boaRootCmd
                                        addBoaCommand(fileName, boaCmd, modType, name, short, long, path, parent, hidden)
                                        if boaCmd != nil </span><span class="cov0" title="0">{
                                                boaCmd = boaCmd.Parent()
                                                if boaCmd == boaRootCmd </span><span class="cov0" title="0">{
                                                        boaCmd = nil
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // add the command and set the new type based on stopWord
                                        boaCmd = addBoaCommand(fileName, boaCmd, modType, name, short, long, path, parent, hidden)
                                }</span>

                                // reset params
                                <span class="cov0" title="0">modType = sw
                                name = ""
                                parent = ""
                                short = ""
                                long = ""
                                path = ""
                                hidden = false</span>
                        } else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(line), "name:") </span><span class="cov0" title="0">{
                                name = strings.TrimSpace(line[5:])
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(line), "parent:") </span><span class="cov0" title="0">{
                                parent = strings.TrimSpace(line[7:])
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(line), "short:") </span><span class="cov0" title="0">{
                                short = strings.TrimSpace(line[6:])
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(line), "long:") </span><span class="cov0" title="0">{
                                long = strings.TrimSpace(line[5:])
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(line), "path:") </span><span class="cov0" title="0">{
                                path = strings.TrimSpace(line[5:])
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(line), "hidden:") </span><span class="cov0" title="0">{
                                hidden = strings.ToLower(strings.TrimSpace(line[7:])) == "true"
                        }</span> else<span class="cov0" title="0"> {
                                if line != "" </span><span class="cov0" title="0">{
                                        cfmt.ErrorE("unrecognized line: " + line)
                                }</span>
                        }
                }
        }

        // handle last command at EOF
        <span class="cov0" title="0">if modType != "" </span><span class="cov0" title="0">{
                addBoaCommand(fileName, boaCmd, modType, name, short, long, path, parent, hidden)
        }</span>
}

// add a command or command to cobra
func addBoaCommand(fileName string, modCmd *cobra.Command, modType string, name string, short string, long string, path string, parent string, hidden bool) *cobra.Command <span class="cov0" title="0">{
        // ignore if modType not set
        if modType == "" || modType == "popCommand" </span><span class="cov0" title="0">{
                return modCmd
        }</span>

        // handle different command and command types
        <span class="cov0" title="0">if modType == "root" </span><span class="cov0" title="0">{
                return setRootValues(name, short, long)
        }</span> else<span class="cov0" title="0"> if modType == "command" </span><span class="cov0" title="0">{
                return addParentCommand(modCmd, name, short, long, parent, hidden)
        }</span> else<span class="cov0" title="0"> if modType == "runCommand" || modType == "fltCommand" || modType == "boaCommand" </span><span class="cov0" title="0">{
                return addCommand(modCmd, modType, name, short, long, path, hidden)
        }</span>

        // bad input file
        <span class="cov0" title="0">cfmt.ErrorE("unrecognized Command in file:", fileName, modType, name, short, long, path)
        os.Exit(1)
        return nil</span>
}

// add a command to the command tree
func addParentCommand(modCmd *cobra.Command, name string, short string, long string, parent string, hidden bool) *cobra.Command <span class="cov0" title="0">{
        if !hidden </span><span class="cov0" title="0">{
                // name and short are required
                if err := checkNameAndShort(name, short); err != nil </span><span class="cov0" title="0">{
                        return modCmd
                }</span>
        } else<span class="cov0" title="0"> {
                short = "hidden"
                long = ""
        }</span>

        <span class="cov0" title="0">if parent != "" </span><span class="cov0" title="0">{
                // set the parent if specified
                if strings.ToLower(parent) == "boaRootCmd" </span><span class="cov0" title="0">{
                        modCmd = nil
                }</span> else<span class="cov0" title="0"> {
                        modCmd = GetCommandByUse(boaRootCmd, parent)
                        if modCmd == nil </span><span class="cov0" title="0">{
                                cfmt.ErrorE("Parent command not found", parent)
                                os.Exit(1)
                        }</span>
                }
        }

        <span class="cov0" title="0">if modCmd != nil </span><span class="cov0" title="0">{
                // check for dupes
                if GetCommandByUse(modCmd, name) != nil </span><span class="cov0" title="0">{
                        if hidden </span><span class="cov0" title="0">{
                                GetCommandByUse(modCmd, name).Hidden = true
                        }</span> else<span class="cov0" title="0"> {
                                cfmt.ErrorE("Command already exists", modCmd.Use, name)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return addCommand(modCmd, "command", name, short, long, "", hidden)
                }</span>
        } else<span class="cov0" title="0"> {
                // check for dupes
                if GetCommandByUse(boaRootCmd, name) != nil </span><span class="cov0" title="0">{
                        if hidden </span><span class="cov0" title="0">{
                                GetCommandByUse(boaRootCmd, name).Hidden = true
                        }</span> else<span class="cov0" title="0"> {
                                cfmt.ErrorE("Command already exists", boaRootCmd.Use, name)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return addCommand(boaRootCmd, "command", name, short, long, "", hidden)
                }</span>
        }

        // set the new command to the parent
        <span class="cov0" title="0">return nil</span>
}

// add a command to a command in the command tree
func addCommand(modCmd *cobra.Command, modType string, name string, short string, long string, path string, hidden bool) *cobra.Command <span class="cov0" title="0">{
        if modType != "command" &amp;&amp; path == "" </span><span class="cov0" title="0">{
                cfmt.ErrorE("path is required", name, short, long, path)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if modType == "boaCommand" </span><span class="cov0" title="0">{
                // read the values from the command metadata if necessary
                name = readFromCommandFile(path, "name", name)
                short = readFromCommandFile(path, "short", short)
                long = readFromCommandFile(path, "long", long)
        }</span>

        <span class="cov0" title="0">if !hidden </span><span class="cov0" title="0">{
                // name and short are required
                if err := checkNameAndShort(name, short); err != nil </span><span class="cov0" title="0">{
                        return modCmd
                }</span>
        } else<span class="cov0" title="0"> {
                short = "hidden"
                long = ""
        }</span>

        // use boaRootCmd if modCmd is nil
        <span class="cov0" title="0">aCmd := modCmd
        if aCmd == nil </span><span class="cov0" title="0">{
                aCmd = boaRootCmd
        }</span>

        // check for dupes
        <span class="cov0" title="0">if GetCommandByUse(aCmd, name) != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("Command already exists", aCmd.Use, name)
                os.Exit(1)
        }</span>

        // add the command
        <span class="cov0" title="0">var cmd *cobra.Command

        switch modType </span>{
        case "boaCommand":<span class="cov0" title="0">
                cmd = addBoaScriptCommand(name, short, long, path)</span>
        case "runCommand":<span class="cov0" title="0">
                cmd = addBashCommand(name, short, long, path)</span>
        case "fltCommand":<span class="cov0" title="0">
                cmd = CreateFltCommand(name, short, long, path)</span>
        case "command":<span class="cov0" title="0">
                cmd = CreateCommand(name, short, long)
                modCmd = cmd</span>
        default:<span class="cov0" title="0">
                break</span>
        }

        <span class="cov0" title="0">cmd.Hidden = hidden
        aCmd.AddCommand(cmd)

        if !cmd.Hidden </span><span class="cov0" title="0">{
                parent := aCmd.Use
                if parent == "kic" || parent == "flt" </span><span class="cov0" title="0">{
                        parent = "root"
                }</span>
        }

        // parent doesn't change
        <span class="cov0" title="0">return modCmd</span>
}

// set the root command values
func setRootValues(name string, short string, long string) *cobra.Command <span class="cov0" title="0">{
        // name and short are required
        if err := checkNameAndShort(name, short); err == nil </span><span class="cov0" title="0">{
                boaRootCmd.Use = name
                boaRootCmd.Short = short

                // this will default to short if not set
                if long != "" </span><span class="cov0" title="0">{
                        boaRootCmd.Long = long
                }</span>
        }

        // reset parent
        <span class="cov0" title="0">return nil</span>
}

// this will exit if name or short are invalid
func checkNameAndShort(name string, short string) error <span class="cov0" title="0">{
        // name and short are required
        if name == "" || short == "" </span><span class="cov0" title="0">{
                if name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("name: is required")
                }</span>
                <span class="cov0" title="0">if short == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("short: is required")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// read the metadata from the command
func readFromCommandFile(path string, key string, value string) string <span class="cov0" title="0">{
        // don't read if already set
        if value != "" </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">key = strings.TrimSpace(strings.ToLower(key)) + ":"
        p := filepath.Join(boaCommandPath, path)

        // read the file into an array
        txt := ReadTextFile(p)
        lines := strings.Split(txt, "\n")

        for i := 0; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                line := strings.TrimSpace(lines[i])

                if strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        // check all comments for metadata
                        line = strings.TrimSpace(strings.TrimLeft(line, "#"))

                        if strings.HasPrefix(strings.ToLower(line), key) </span><span class="cov0" title="0">{
                                // extract the metadata
                                line = strings.TrimSpace(line[len(key):])
                                return line
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// add a command that has sub-commands
func CreateCommand(use string, short string, long string) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,
        }

        return cmd
}</span>

// create a command that runs the boa script
func AddBoaScriptCommand(use string, short string, long string, command string) *cobra.Command <span class="cov0" title="0">{
        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                ShellExecArgsE(filepath.Join(boaCommandPath, command), args)
                        }</span> else<span class="cov0" title="0"> {
                                ShellExecE(filepath.Join(boaCommandPath, command))
                        }</span>
                },
        }

        <span class="cov0" title="0">return runCmd</span>
}

// create a command that runs the bash command
func AddBashCommand(use string, short string, long string, command string) *cobra.Command <span class="cov0" title="0">{
        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                ShellExecArgsE(command, args)
                        }</span> else<span class="cov0" title="0"> {
                                ShellExecE(command)
                        }</span>
                },
        }

        <span class="cov0" title="0">return runCmd</span>
}

// create a command that runs the boa script
func addBoaScriptCommand(use string, short string, long string, command string) *cobra.Command <span class="cov0" title="0">{
        cmdPath := GetBoaCommandPath()

        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                ShellExecArgsE(filepath.Join(cmdPath, command), args)
                        }</span> else<span class="cov0" title="0"> {
                                ShellExecE(filepath.Join(cmdPath, command))
                        }</span>
                },
        }

        <span class="cov0" title="0">return runCmd</span>
}

// create a command that runs the bash command
func addBashCommand(use string, short string, long string, command string) *cobra.Command <span class="cov0" title="0">{
        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                ShellExecArgsE(command, args)
                        }</span> else<span class="cov0" title="0"> {
                                ShellExecE(command)
                        }</span>
                },
        }

        <span class="cov0" title="0">return runCmd</span>
}

// execute a command in bin/.kic/commands
func ExecCommandE(cmd string) error <span class="cov0" title="0">{
        path := GetBoaCommandPath() + cmd

        // execute the file with "bash -c" if it exists
        _, err := os.Stat(path)

        if err == nil </span><span class="cov0" title="0">{
                cfmt.Info("Running command: " + cmd)

                err = ShellExecE(fmt.Sprintf("%s %s", path, os.Args))
        }</span>

        <span class="cov0" title="0">return err</span>
}

var grep string

// create a command that runs the bash command across the fleet
func CreateFltCommand(use string, short string, long string, command string) *cobra.Command <span class="cov0" title="0">{
        fltCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // VM cli could be in ./cli (defalut) or ./gitops
                        script := os.Getenv("AKDC_VM_REPO")

                        if script == "" </span><span class="cov0" title="0">{
                                script = "gitops"
                        }</span>

                        <span class="cov0" title="0">script = filepath.Join(".", script, "vm", "scripts", command)

                        // add the paramaters
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                script += " " + strings.Join(args, " ")
                        }</span>

                        // check-setup can run before the cli is fully setup
                        <span class="cov0" title="0">if command == "check-setup" </span><span class="cov0" title="0">{
                                script = "tail -n1 status"
                        }</span>

                        <span class="cov0" title="0">return ExecClusters(script, grep)</span>
                },
        }

        <span class="cov0" title="0">fltCmd.PersistentFlags().StringVarP(&amp;grep, "grep", "g", "", "grep conditional to filter by host")

        return fltCmd</span>
}

// run a command on all clusters
func ExecClusters(cmd string, grep string) error <span class="cov0" title="0">{
        hostIPs, err := ReadHostIPs(grep)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ch := make(chan string)

        for _, hostIP := range hostIPs </span><span class="cov0" title="0">{
                cols := strings.Split(hostIP, "\t")

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        go ExecCluster(cols[0], cols[1], cmd, ch)
                }</span>
        }

        // todo - add timeout
        <span class="cov0" title="0">for i := 0; i &lt; len(hostIPs); i++ </span><span class="cov0" title="0">{
                &lt;-ch
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// run a command on one cluster via ssh
func ExecCluster(host string, ip string, cmd string, ch chan string) <span class="cov0" title="0">{
        cmd = fmt.Sprintf("ssh -p 2222 -o \"StrictHostKeyChecking=no\" -o ConnectTimeout=5 akdc@%s %s", ip, cmd)

        res, _ := ShellExecOut(cmd, true)

        if !strings.HasSuffix(res, "\n") </span><span class="cov0" title="0">{
                res += "\n"
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(strings.TrimSpace(res), host) </span><span class="cov0" title="0">{
                fmt.Print(res)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%-25s %s", host, res)
        }</span>

        <span class="cov0" title="0">ch &lt;- host</span>
}

// add a script command to a command in the command tree
func AddScriptCommand(parent *cobra.Command, name string, short string, script string) error <span class="cov0" title="0">{
        if script == "" </span><span class="cov0" title="0">{
                cfmt.ErrorE("script is required", name, short)
                os.Exit(1)
        }</span>

        // name and short are required
        <span class="cov0" title="0">if name == "" || short == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("name and short are required")
        }</span>

        // add the command
        <span class="cov0" title="0">parent.AddCommand(CreateScriptCommand(name, short, script))

        return nil</span>
}

// create a command that runs the script
func CreateScriptCommand(use string, short string, command string) *cobra.Command <span class="cov0" title="0">{
        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                for i := len(args); i &gt; 0; i-- </span><span class="cov0" title="0">{
                                        command = strings.ReplaceAll(command, "$"+strconv.Itoa(i), args[i-1])
                                }</span>
                        }

                        <span class="cov0" title="0">return ShellExecE(command)</span>
                },
        }

        <span class="cov0" title="0">return runCmd</span>
}

// add the command to root if it doesn't exist
func AddCommandIfNotExist(parent *cobra.Command, cmd *cobra.Command) <span class="cov0" title="0">{
        if parent != nil &amp;&amp; cmd != nil </span><span class="cov0" title="0">{
                if GetCommandByUse(parent, cmd.Use) == nil </span><span class="cov0" title="0">{
                        parent.AddCommand(cmd)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "bytes"
        "io"
        "kic/boa/cfmt"
        "os"
        "strings"
        "testing"

        "github.com/spf13/cobra"
)

func ExecCmdNoErrorE(t *testing.T, c *cobra.Command, args ...string) error <span class="cov0" title="0">{
        t.Helper()

        arg := ""
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                arg = args[0]
        }</span>

        <span class="cov0" title="0">cfmt.Info(t.Name(), c.Name(), arg)

        c.SetArgs(args)
        err := c.Execute()

        if err != nil </span><span class="cov0" title="0">{
                t.Error("Unexpected error:", err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func ExecCmdWithErrorE(t *testing.T, errMatch string, c *cobra.Command, args ...string) error <span class="cov0" title="0">{
        t.Helper()

        c.SetArgs(args)
        err := c.Execute()

        if err == nil </span><span class="cov0" title="0">{
                t.Error("Expected error", errMatch)
        }</span> else<span class="cov0" title="0"> {
                if !strings.Contains(err.Error(), errMatch) </span><span class="cov0" title="0">{
                        t.Errorf("Expected error %s; got error %s", errMatch, err)
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

// execute command and return result and error
// warning: this is not thread safe
func ExecCmdWithResultsE(t *testing.T, resultMatch string, errMatch string, c *cobra.Command, args ...string) (string, error) <span class="cov0" title="0">{
        t.Helper()

        var (
                old *os.File
                r   *os.File
                w   *os.File
                buf *bytes.Buffer
        )

        // redirect stdout so we can capture
        old = os.Stdout
        r, w, _ = os.Pipe()
        os.Stdout = w

        buf = new(bytes.Buffer)
        c.SetOut(buf)
        c.SetErr(buf)

        c.SetArgs(args)
        err := c.Execute()

        // reset stdout
        w.Close()
        os.Stdout = old
        io.Copy(buf, r)
        result := strings.TrimSpace(buf.String())

        if !strings.Contains(result, resultMatch) </span><span class="cov0" title="0">{
                t.Error("Result does not match:", resultMatch)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), errMatch) </span><span class="cov0" title="0">{
                        t.Errorf("Expected error %s; got error %s", errMatch, err)
                }</span>
        } else<span class="cov0" title="0"> if errMatch != "" </span><span class="cov0" title="0">{
                t.Errorf("Expected error %s, got nil", errMatch)
        }</span>

        <span class="cov0" title="0">return result, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cfmt

import (
        "fmt"
        "os"
        "runtime"
        "strings"
)

var (
        Reset  string
        Blue   string
        Cyan   string
        Gray   string
        Green  string
        Purple string
        Red    string
        White  string
        Yellow string
)

// print an info message in cyan
func Info(msg ...interface{}) <span class="cov8" title="1">{
        fmt.Print(Cyan)
        fmt.Print(msg...)
        fmt.Println(Reset)
}</span>

// print the error in red and return params as error
func ErrorE(msg ...interface{}) error <span class="cov8" title="1">{
        fmt.Print(Red)
        fmt.Print(msg...)
        fmt.Println(Reset)
        return fmt.Errorf("%v", fmt.Sprint(msg...))
}</span>

func init() <span class="cov8" title="1">{
        // Windows doesn't support ANSI colors
        if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                Reset = "\033[0m"
                Blue = "\033[34m"
                Cyan = "\033[36m"
                Gray = "\033[37m"
                Green = "\033[32m"
                Purple = "\033[35m"
                Red = "\033[31m"
                White = "\033[97m"
                Yellow = "\033[33m"
        }</span>
}

// append text to path
func FAppendToFile(path string, text string) error <span class="cov0" title="0">{
        f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

        if err != nil </span><span class="cov0" title="0">{
                return ErrorE(err)
        }</span>

        <span class="cov0" title="0">defer f.Close()

        if _, err := f.WriteString(text); err != nil </span><span class="cov0" title="0">{
                return ErrorE(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Title(val string) string <span class="cov0" title="0">{
        ret := val

        if val != "" </span><span class="cov0" title="0">{
                ret = strings.ToUpper(val[0:1])
                ret += val[1:]
        }</span>

        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "fmt"
        "kic/boa/cfmt"
        "log"
        "os"
        "path"
        "path/filepath"
        "strings"
)

// read key from ~/.kic
func ReadConfigValue(key string) string <span class="cov8" title="1">{
        key = strings.TrimSpace(key)

        if !strings.HasSuffix(key, ":") </span><span class="cov8" title="1">{
                key += ":"
        }</span>

        <span class="cov8" title="1">config := os.Getenv("HOME") + "/.kic"

        if _, err := os.Stat(config); err == nil </span><span class="cov8" title="1">{
                lines := ReadLinesFromFile(config)

                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        if strings.HasPrefix(line, key) </span><span class="cov8" title="1">{
                                line = strings.TrimSpace(strings.Replace(line, key, "", 1))
                                return line
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// read the ips file
func ReadHostIPs(grep string) ([]string, error) <span class="cov8" title="1">{
        command := ""

        if _, err := os.Stat("./ips"); err != nil </span><span class="cov8" title="1">{
                file := ReadConfigValue("defaultIPs:")
                if file != "" </span><span class="cov8" title="1">{
                        command = "cat " + file + " | grep -v '^#' | sort"
                }</span>
        } else<span class="cov0" title="0"> {
                command = "cat ips | grep -v '^#' | sort"
        }</span>

        <span class="cov8" title="1">if command == "" </span><span class="cov0" title="0">{
                cfmt.ErrorE("fleet file not found")
        }</span>

        <span class="cov8" title="1">if grep != "" </span><span class="cov8" title="1">{
                err := CheckForBadChars(grep, "grep")
                if err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE(err)
                        return nil, err
                }</span>

                <span class="cov8" title="1">command += " | grep " + grep</span>
        }

        <span class="cov8" title="1">res, err := ShellExecOut(command, false)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">lines := strings.Split(res, "\n")

        var ips []string = nil

        for _, line := range lines </span><span class="cov0" title="0">{
                ip := strings.Split(line, "\t")

                if len(ip) &gt; 1 </span><span class="cov0" title="0">{
                        ips = append(ips, line)
                }</span>
        }

        <span class="cov0" title="0">return ips, nil</span>
}

// read a completion file
func ReadCompletionFile(fileName string) ([]string, error) <span class="cov0" title="0">{
        path := path.Join(GetBoaPath(), fileName)

        if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ReadLinesFromFile(path), nil</span>
}

// get the path to the executable's directory
func GetBinDir() string <span class="cov8" title="1">{
        env := strings.ToUpper(GetBinName() + "_PATH")

        // read from env var
        ex := os.Getenv(env)
        if ex != "" </span><span class="cov0" title="0">{
                return ex
        }</span>

        <span class="cov8" title="1">ex, _ = os.Getwd()

        // return the working directory on tests
        if strings.HasPrefix(ex, "/tmp/") || strings.HasPrefix(GetBinName(), "__debug") </span><span class="cov0" title="0">{
                return ex
        }</span>

        <span class="cov8" title="1">ex, err := os.Executable()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // get the parent of bin
        <span class="cov8" title="1">return filepath.Dir(ex)</span>
}

// get the file name from the executing directory
func GetBinName() string <span class="cov8" title="1">{
        ex, err := os.Executable()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // get the parent of bin
        <span class="cov8" title="1">return filepath.Base(ex)</span>
}

// get the path to the commands (i.e. /bin/kic/.kic)
func GetBoaPath() string <span class="cov8" title="1">{
        ex := os.Getenv("KIC_CONFIG")
        if ex != "" </span><span class="cov0" title="0">{
                return ex
        }</span>

        <span class="cov8" title="1">boaPath := GetBinDir()
        app := GetBinName()
        appConfig := "." + app

        // check current directory first
        if local, err := os.Getwd(); err == nil </span><span class="cov8" title="1">{
                local = filepath.Join(local, appConfig)

                if _, err := os.Stat(local); err == nil </span><span class="cov0" title="0">{
                        return local
                }</span>
        }

        // running in debugger
        <span class="cov8" title="1">if strings.HasPrefix(app, "__debug") </span><span class="cov0" title="0">{
                // assume package name == source directory
                app = filepath.Base(boaPath)
                // todo - fix this appConfig = "." + app
                appConfig = ".flt"

                if _, err := os.Stat(appConfig); err != nil </span><span class="cov0" title="0">{
                        // walk the path to find the first bin dir
                        tpath := filepath.Dir(boaPath)
                        _, err := os.Stat(filepath.Join(tpath, "bin", appConfig))

                        for err != nil &amp;&amp; tpath != "/" </span><span class="cov0" title="0">{
                                tpath = filepath.Dir(tpath)
                                _, err = os.Stat(filepath.Join(tpath, "bin", appConfig))
                        }</span>

                        <span class="cov0" title="0">if tpath != "/" </span><span class="cov0" title="0">{
                                boaPath = filepath.Join(tpath, "bin")
                        }</span>
                }
        }

        // complete the path
        <span class="cov8" title="1">return filepath.Join(boaPath, appConfig)</span>
}

// get the path to the boa commands
func GetBoaCommandPath() string <span class="cov0" title="0">{
        return filepath.Join(GetBoaPath(), "commands")
}</span>

// get the path to the repo base
func GetRepoBase() string <span class="cov8" title="1">{
        base := os.Getenv("REPO_BASE")

        if base == "" </span><span class="cov0" title="0">{
                ex, err := os.Executable()

                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">base = filepath.Dir(ex)
                base = filepath.Dir(base)

                if strings.HasSuffix(base, "src") </span><span class="cov0" title="0">{
                        base = filepath.Dir(base)
                }</span>
        }

        <span class="cov8" title="1">return base</span>
}

// read a text file from the boa directory
// i.e. /bin/kic/.kic
func ReadTextFileFromBoaDir(name string) string <span class="cov8" title="1">{
        path := filepath.Join(GetBoaPath(), name)
        return ReadTextFile(path)
}</span>

// read a file and return the text
func ReadTextFile(path string) string <span class="cov8" title="1">{
        content, err := os.ReadFile(path)

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return string(content)</span>
}

// read lines from a text file
func ReadLinesFromFile(path string) []string <span class="cov8" title="1">{
        return strings.Split(ReadTextFile(path), "\n")
}</span>

// check for dangerous characters sent to bash
func CheckForBadChars(source string, param string) error <span class="cov8" title="1">{

        if source != "" </span><span class="cov8" title="1">{
                badChars := "|&amp;;&lt;&gt;"

                for _, ch := range badChars </span><span class="cov8" title="1">{
                        if strings.Contains(source, string(ch)) </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid character in parameter %s", param)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "bytes"
        "os"
        "os/exec"
)

// execute a bash command with args
func ShellExecArgsE(cmd string, args []string) error <span class="cov8" title="1">{
        command := cmd
        for _, arg := range args </span><span class="cov0" title="0">{
                command += " " + arg
        }</span>
        <span class="cov8" title="1">return ShellExecE(command)</span>
}

// execute a bash command and return stdout
func ShellExecOut(cmd string, showErrors bool) (string, error) <span class="cov8" title="1">{
        shell := exec.Command("bash", "-c", cmd)

        var out bytes.Buffer
        shell.Stdout = &amp;out

        // show errors
        if showErrors </span><span class="cov0" title="0">{
                shell.Stderr = os.Stderr
        }</span>

        <span class="cov8" title="1">err := shell.Run()

        return out.String(), err</span>
}

// execute a bash command
func ShellExecE(cmd string) error <span class="cov8" title="1">{
        shell := exec.Command("bash", "-c", cmd)

        shell.Stdin = os.Stdin
        shell.Stdout = os.Stdout
        shell.Stderr = os.Stderr

        return shell.Run()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var AzCmd = &amp;cobra.Command{
        Use:   "az",
        Short: "Azure CLI commands (customized)",
}

func init() <span class="cov8" title="1">{
        boa.AddCommandIfNotExist(AzCmd, boa.CreateScriptCommand("groups", "List Azure groups", fltAzGroupsScript()))
        boa.AddCommandIfNotExist(AzCmd, boa.CreateScriptCommand("login", "Login to Azure using the project's Service Principal", fltAzLoginScript()))
        boa.AddCommandIfNotExist(AzCmd, boa.CreateScriptCommand("logout", "Logout of Azure", fltAzLogoutScript()))
        boa.AddCommandIfNotExist(AzCmd, boa.CreateScriptCommand("vms", "List Azure VMs in the resource group", fltAzVMsScript()))
}</span>

func fltAzGroupsScript() string <span class="cov8" title="1">{
        return "az group list -o table | sort | grep -e central- -e east- -e west- -e corp- -e retail-edge -e fleet"
}</span>

func fltAzLoginScript() string <span class="cov8" title="1">{
        return "az login --service-principal --username $AKDC_SP_ID --tenant $AKDC_TENANT --password $AKDC_SP_KEY"
}</span>

func fltAzLogoutScript() string <span class="cov8" title="1">{

        return "az logout"
}</span>

func fltAzVMsScript() string <span class="cov8" title="1">{
        return `
                rg=$1

                if [ "$rg" = "" ]
                then
                        rg="$FLT_RG"
                fi

                if [ "$rg" = "" ]
                then
                        rg="$(git branch --show-current)"
                fi

                if [ "$rg" = "" ]
                then
                        echo "usage: flt az vms resourceGroup"
                        exit 0
                fi

                echo ""
                echo "getting VMs in resource group: $rg"
                echo ""

                hdrsort()
                {
                        read -r
                        printf "%s\\n" "$REPLY"
                        sort
                }

                az vm list --query '[].name' -o table -g $rg | hdrsort
        `
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// check the clusters in the fleet
var CheckCmd = &amp;cobra.Command{
        Use:   "check",
        Short: "Check cluster status",
}

func init() <span class="cov8" title="1">{
        checkAppCmd := boa.CreateFltCommand("app", "Check app status on each cluster", "", "check-app")
        checkAppCmd.ValidArgsFunction = validArgsFleetCheckApp

        CheckCmd.AddCommand(checkAppCmd)

        CheckCmd.AddCommand(boa.CreateFltCommand("flux", "Check flux status on each cluster", "", "check-flux"))
        CheckCmd.AddCommand(boa.CreateFltCommand("heartbeat", "Check https heartbeat on each cluster", "", "check-heartbeat"))
        CheckCmd.AddCommand(boa.CreateFltCommand("logs", "Check the cloudinit logs on each cluster", "", "check-logs"))
        CheckCmd.AddCommand(boa.CreateFltCommand("setup", "Check setup status on each cluster", "", "check-setup"))
}</span>

// validate flt check app arg
func validArgsFleetCheckApp(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        apps, err := boa.ReadCompletionFile("flt-check-app-completion")

        if err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // only one arg
        <span class="cov0" title="0">if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // sugest from the completion file
        <span class="cov0" title="0">return apps, cobra.ShellCompDirectiveNoFileComp</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
)

var (
        // variables for options
        clusters          []string
        group             string
        location          string
        repo              string
        branch            string
        pem               string
        key               string
        quiet             bool
        ssl               string
        dnsRG             string
        gitops            bool
        gitopsOnly        bool
        dapr              bool
        arcEnabled        bool
        digitalOcean      bool
        dryRun            bool
        debug             bool
        cores             int
        verbose           bool
        sku               string
        managedIdentityID string

        // kic fleet create command
        CreateCmd = &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new cluster",
                Args:  validateCreateCmd,
                RunE:  runCreateCmd,
        }
)

// add kic fleet create specific flags
func init() <span class="cov8" title="1">{
        // get defaults from env var
        tRepo := os.Getenv("AKDC_REPO")
        tSsl := os.Getenv("AKDC_SSL")
        tGitOps := os.Getenv("AKDC_GITOPS") == "true"

        CreateCmd.Flags().StringSliceVarP(&amp;clusters, "clusters", "c", []string{}, "Kubernetes cluster name(s) (required)")
        CreateCmd.MarkFlagRequired("clusters")
        CreateCmd.Flags().StringVarP(&amp;group, "group", "g", "", "Azure resource group name")
        CreateCmd.Flags().StringVarP(&amp;location, "location", "l", "centralus", "Azure location")
        CreateCmd.Flags().StringVarP(&amp;repo, "repo", "r", tRepo, "GitOps repo name")
        CreateCmd.Flags().StringVarP(&amp;branch, "branch", "b", "", "GitOps branch name")
        CreateCmd.Flags().StringVarP(&amp;ssl, "ssl", "s", tSsl, "SSL domain name")
        CreateCmd.Flags().StringVarP(&amp;pem, "pem", "p", "~/.ssh/certs.pem", "Path to SSL .pem file")
        CreateCmd.Flags().StringVarP(&amp;key, "key", "k", "~/.ssh/certs.key", "Path to SSL .key file")
        CreateCmd.Flags().StringVar(&amp;dnsRG, "dns-resource-group", "tld", "DNS Resource Group")
        CreateCmd.Flags().BoolVar(&amp;dapr, "dapr", false, "Install Dapr and Radius")
        CreateCmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false, "Quiet mode")
        CreateCmd.Flags().BoolVarP(&amp;debug, "debug", "d", false, "Create VM in debug mode")
        CreateCmd.Flags().BoolVarP(&amp;arcEnabled, "arc", "a", false, "Connect kubernetes cluster to Azure via Azure ARC")
        CreateCmd.Flags().BoolVar(&amp;digitalOcean, "do", false, "Generate setup script for Digital Ocean droplet")
        CreateCmd.Flags().BoolVar(&amp;gitops, "gitops", tGitOps, "Generate GitOps targets in ./config")
        CreateCmd.Flags().BoolVar(&amp;gitopsOnly, "gitops-only", false, "Only generate GitOps targets in ./config")
        CreateCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show values that would be used")
        CreateCmd.Flags().BoolVar(&amp;verbose, "verbose", false, "Show verbose output")
        CreateCmd.Flags().IntVar(&amp;cores, "cores", 4, "VM core count")
        CreateCmd.Flags().StringVar(&amp;sku, "sku", "", "Azure VM SKU")

        CreateCmd.RegisterFlagCompletionFunc("clusters", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return getClusterComplete(), cobra.ShellCompDirectiveDefault
        }</span>)

        <span class="cov8" title="1">CreateCmd.RegisterFlagCompletionFunc("cores", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return []string{"02", "04", "08", "16", "32"}, cobra.ShellCompDirectiveDefault
        }</span>)
}

// get a list of valid clusters for shell completion
func getClusterComplete() []string <span class="cov0" title="0">{
        return []string{
                "central-tx-dallas-101",
                "central-tx-dallas-102",
                "central-tx-dallas-103",
                "central-tx-dallas-104",
                "central-tx-dallas-105",
                "east-ga-atl-101",
                "east-ga-atl-102",
                "east-ga-atl-103",
                "east-ga-atl-104",
                "east-ga-atl-105",
                "west-ca-la-101",
                "west-ca-la-102",
                "west-ca-la-103",
                "west-ca-la-104",
                "west-ca-la-105",
        }
}</span>

// validation function for CreateCmd
func validateCreateCmd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        hasError := false

        if len(clusters) == 0 </span><span class="cov0" title="0">{
                cfmt.ErrorE("--cluster is a required parameter")
                hasError = true
        }</span>

        // validate ssl and domain
        <span class="cov8" title="1">hasError = hasError &amp;&amp; validateSSL()

        // validate cluster name against reserved prefixes (if set)
        hasError = hasError &amp;&amp; validateClusterPrefix()

        // validate cores
        hasError = hasError &amp;&amp; validateCores()

        // default resource group is cluster name
        if group == "" </span><span class="cov8" title="1">{
                if len(clusters) == 1 </span><span class="cov8" title="1">{
                        group = strings.TrimSpace(clusters[0])
                }</span> else<span class="cov0" title="0"> {
                        hasError = true
                        cfmt.ErrorE("you must specify --resource-group")
                }</span>
        }

        <span class="cov8" title="1">if hasError </span><span class="cov0" title="0">{
                cfmt.ErrorE("create command aborted")
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validate --ssl
func validateSSL() bool <span class="cov0" title="0">{
        hasError := false

        if ssl != "" </span><span class="cov0" title="0">{
                if pem == "" </span><span class="cov0" title="0">{
                        cfmt.ErrorE("you must specify --pem to use --ssl")
                        hasError = true
                }</span>

                <span class="cov0" title="0">if key == "" </span><span class="cov0" title="0">{
                        cfmt.ErrorE("you must specify --key to use --ssl")
                        hasError = true
                }</span>

                <span class="cov0" title="0">if len(ssl) &lt; 3 </span><span class="cov0" title="0">{
                        cfmt.ErrorE("--ssl parameter is too short")
                        hasError = true
                }</span>

                <span class="cov0" title="0">if !strings.Contains(ssl, ".") </span><span class="cov0" title="0">{
                        cfmt.ErrorE("malformed --ssl parameter")
                        hasError = true
                }</span>

                <span class="cov0" title="0">if managedIdentityID == "" </span><span class="cov0" title="0">{
                        cfmt.ErrorE("managed identity is required to use --ssl")
                        fmt.Println("please export AKDC_MI or save to $HOME/.ssh/mi.key")
                        hasError = true
                }</span>
        }
        <span class="cov0" title="0">return hasError</span>
}

// validate --cores
func validateCores() bool <span class="cov0" title="0">{
        validCores := map[int]int{2: 2, 4: 4, 8: 8, 16: 16, 32: 32}
        _, ok := validCores[cores]

        if !ok </span><span class="cov0" title="0">{
                cfmt.ErrorE("invalid --cores")
                fmt.Println("  valid: 2, 4, 8, 16, 32")
        }</span>

        <span class="cov0" title="0">return ok</span>
}

// validate cluster prefix
func validateClusterPrefix() bool <span class="cov0" title="0">{
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                cl := strings.TrimSpace(strings.ToLower(cluster))

                blocked := boa.ReadConfigValue("reservedClusterPrefixes:")

                lines := strings.Split(blocked, " ")

                for _, line := range lines </span><span class="cov0" title="0">{
                        line = strings.ToLower(strings.TrimSpace(line))

                        if line != "" &amp;&amp; strings.HasPrefix(cl, line) </span><span class="cov0" title="0">{
                                cfmt.ErrorE("cluster name is invalid - reserved prefix")
                                return false
                        }</span>
                }
        }

        <span class="cov0" title="0">return true</span>
}

// validate logged in to Azure
func validateAzureLogin() error <span class="cov0" title="0">{
        _, err := boa.ShellExecOut("az account show --query tenantId -o tsv", false)
        return err
}</span>

// validate Azure region
func validateLocation(loc string) error <span class="cov0" title="0">{
        res, err := boa.ShellExecOut("az account list-locations --query '[].name' -o table |  grep -x -i "+location, false)

        if err != nil || res == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", "invalid Azure Region")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validate VM SKU
func validateVmSku(loc string, vmSku string) error <span class="cov0" title="0">{
        res, err := boa.ShellExecOut("az vm list-sizes -o table -l "+location+" | grep -w -i "+vmSku, false)

        if err != nil || res == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", "invalid VM SKU")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validate PWD is a git repo
func validateRepo() bool <span class="cov0" title="0">{
        cfmt.Info("Validating parameters")

        // required for --gitops
        if gitops || gitopsOnly </span><span class="cov0" title="0">{
                res, err := boa.ShellExecOut("git branch --show-current", false)

                if err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("Not a git repo")
                        cfmt.Info("Please re-run from a git repo")
                        return false
                }</span>

                <span class="cov0" title="0">res = strings.TrimSpace(res)

                // set branch to current branch
                if branch == "" </span><span class="cov0" title="0">{
                        branch = res
                }</span>
        }

        <span class="cov0" title="0">return branch != ""</span>
}

// run the command
func runCreateCmd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // trim the values
        for i, cluster := range clusters </span><span class="cov8" title="1">{
                clusters[i] = strings.TrimSpace(cluster)
        }</span>

        <span class="cov8" title="1">if !digitalOcean </span><span class="cov0" title="0">{
                // validate PWD is a git repo
                if !validateRepo() </span><span class="cov0" title="0">{
                        cfmt.ErrorE("invalid repo")
                        return nil
                }</span>

                // get mi from env var
                <span class="cov0" title="0">if managedIdentityID == "" </span><span class="cov0" title="0">{
                        managedIdentityID = os.Getenv("AKDC_MI")
                }</span>

                // read mi from $HOME/.ssh/mi.key
                <span class="cov0" title="0">if managedIdentityID == "" </span><span class="cov0" title="0">{
                        path := os.Getenv("HOME") + "/.ssh/mi.key"
                        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                                managedIdentityID = boa.ReadTextFile(path)
                        }</span>
                }

                // validate azure login
                <span class="cov0" title="0">if validateAzureLogin() != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("please run az login first")
                        return nil
                }</span>
                // validate location
                <span class="cov0" title="0">location = strings.ToLower(location)

                if err := validateLocation(location); err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("Invalid location")
                        cfmt.Info("Valid Locations")
                        boa.ShellExecE("az account list-locations --query '[].name' -o table | sort")
                        fmt.Println()
                        cfmt.ErrorE("Invalid location")
                        return nil
                }</span>

                // SKU was not specified - try defaults
                <span class="cov0" title="0">if sku == "" </span><span class="cov0" title="0">{
                        // check the D4as_V5 SKU
                        sku = "Standard_D" + strconv.Itoa(cores) + "as_v5"

                        err := validateVmSku(location, sku)

                        if err != nil </span><span class="cov0" title="0">{
                                // check the D4s_v5 SKU
                                sku = "Standard_D" + strconv.Itoa(cores) + "s_v5"
                        }</span>
                }

                // validate VM SKU
                <span class="cov0" title="0">if err := validateVmSku(location, sku); err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("Invalid SKU")
                        cfmt.Info("Valid SKUs for region: " + location)
                        boa.ShellExecE("az vm list-sizes -l " + location + " -o table | grep _v5 | grep Standard_D" + " |awk '{print $3}' | sort")
                        fmt.Println()
                        cfmt.ErrorE("Invalid SKU")
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                return doDryRun()
        }</span>

        // add the GitOps target
        <span class="cov0" title="0">if gitops || gitopsOnly </span><span class="cov0" title="0">{
                for _, cluster := range clusters </span><span class="cov0" title="0">{
                        addTargetE(cluster)
                        cfmt.Info("Created GitOps config: ", cluster)
                }</span>

                <span class="cov0" title="0">if len(clusters) &gt; 1 </span><span class="cov0" title="0">{
                        if err := updateGitOpsRepoE(); err != nil </span><span class="cov0" title="0">{
                                cfmt.ErrorE("update GitOps repo failed")
                                return err
                        }</span>
                }

                // exit
                <span class="cov0" title="0">if gitopsOnly </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // create the setup script from the template
        <span class="cov0" title="0">for _, cluster := range clusters </span><span class="cov0" title="0">{
                createVMSetupScript(cluster)
        }</span>

        <span class="cov0" title="0">if digitalOcean </span><span class="cov0" title="0">{
                // no more automation for Digital Ocean droplets
                cfmt.Info("Digital Ocean template created")
                return nil
        }</span>

        // create the azure resource group
        <span class="cov0" title="0">if err := createGroup(); err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("createGroup Failed: ", group)
                return nil
        }</span>

        <span class="cov0" title="0">ch := make(chan string)

        max := 0
        current := 0
        // only run 5 go subs per core
        maxRoutines := runtime.NumCPU() * 5

        for _, cluster := range clusters </span><span class="cov0" title="0">{

                if vmExists(cluster) </span><span class="cov0" title="0">{
                        os.Remove("cluster-" + cluster + ".sh")
                        cfmt.ErrorE("Azure VM Exists: ", cluster)
                }</span> else<span class="cov0" title="0"> {

                        for current &gt; maxRoutines </span><span class="cov0" title="0">{
                                &lt;-ch
                                max--
                                current--
                        }</span>

                        <span class="cov0" title="0">current++
                        max++
                        go createAzureVm(cluster, ch)</span>
                }
        }

        // wait for the go routines to finish
        <span class="cov0" title="0">for max &gt; 0 </span><span class="cov0" title="0">{
                &lt;-ch
                max--
        }</span>

        <span class="cov0" title="0">cfmt.Info("Fleet create complete")

        return nil</span>
}

func createAzureVm(cluster string, ch chan string) <span class="cov0" title="0">{
        // create the vm and get the IP
        ip := createVM(cluster)

        // remove the cluster template
        os.Remove("cluster-" + cluster + ".sh")

        // success
        if ip != "" </span><span class="cov0" title="0">{
                fmt.Println("VM Created: ", cluster)
        }</span> else<span class="cov0" title="0"> {
                cfmt.ErrorE("VM Creation Failed: ", cluster)
        }</span>

        <span class="cov0" title="0">ch &lt;- cluster</span>
}

// handle --dry-run
func doDryRun() error <span class="cov8" title="1">{
        fmt.Println("Cluster:             ", clusters)
        fmt.Println("Cores:               ", cores)
        fmt.Println("Group:               ", group)

        if !digitalOcean </span><span class="cov0" title="0">{
                fmt.Println("VM SKU:              ", sku)
        }</span>

        <span class="cov8" title="1">mi := "n/a"
        if strings.Contains(managedIdentityID, "/Microsoft.ManagedIdentity/") </span><span class="cov0" title="0">{
                miParts := strings.Split(managedIdentityID, "/")
                mi = miParts[len(miParts)-1]
        }</span>

        <span class="cov8" title="1">fmt.Println("Managed Identity:    ", mi)
        fmt.Println("Location:            ", location)
        fmt.Println("Repo:                ", repo)
        fmt.Println("Branch:              ", branch)

        if len(ssl) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Println("SSL Domain:          ", ssl)
                fmt.Println("SSL pem:             ", pem)
                fmt.Println("SSL key:             ", key)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("SSL Domain:           none")
        }</span>

        <span class="cov8" title="1">fmt.Println("Enable GitOps:       ", gitops)
        fmt.Println("Enable Arc:          ", arcEnabled)
        fmt.Println("Enable Dapr:         ", dapr)
        fmt.Println("Enable Digital Ocean:", digitalOcean)

        if !digitalOcean </span><span class="cov0" title="0">{
                fmt.Println("Group Exists:        ", groupExists())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// check to see if the Azure Resource Group exists
func groupExists() bool <span class="cov0" title="0">{
        ex, _ := boa.ShellExecOut("az group exists -g "+group, false)
        return strings.HasPrefix(ex, "true")
}</span>

// check to see if the VM exists in the RG
func vmExists(cluster string) bool <span class="cov0" title="0">{
        command := fmt.Sprintf("az vm show -g %s --name %s --query 'name' -o tsv", group, cluster)
        res, _ := boa.ShellExecOut(command, false)
        return strings.EqualFold(cluster, strings.TrimSpace(res))
}</span>

// get the path to template file
func getTemplatePath() string <span class="cov0" title="0">{
        return boa.GetBoaPath() + "/fleet-vm.templ"
}</span>

// create Azure Resource Group
func createGroup() error <span class="cov0" title="0">{
        // don't create the group if it exists
        if groupExists() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfmt.Info("Creating Azure Resource Group")

        rgTags := "akdc=true"
        if ssl != "" </span><span class="cov0" title="0">{
                rgTags += " zone=" + ssl
        }</span>

        <span class="cov0" title="0">command := "az group create -l " + location + " -n " + group + " -o table --tags " + rgTags

        err := boa.ShellExecE(command)
        if err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE(err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// create vm setup script
func createVMSetupScript(cluster string) <span class="cov0" title="0">{
        os.Remove("cluster-" + cluster + ".sh")

        // create the custom VM script
        content, err := os.ReadFile(getTemplatePath())

        if err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE(err)
                return
        }</span>

        // add the domain name if exists
        <span class="cov0" title="0">fqdn := cluster
        if ssl != "" </span><span class="cov0" title="0">{
                fqdn += "." + ssl
        }</span>

        // create the vm setup script from the template
        <span class="cov0" title="0">command := string(content)
        command = strings.ReplaceAll(command, "{{cluster}}", cluster)
        command = strings.ReplaceAll(command, "{{dapr}}", strconv.FormatBool(dapr))
        command = strings.ReplaceAll(command, "{{debug}}", strconv.FormatBool(debug))
        command = strings.ReplaceAll(command, "{{fqdn}}", fqdn)
        command = strings.ReplaceAll(command, "{{repo}}", repo)
        command = strings.ReplaceAll(command, "{{branch}}", branch)
        command = strings.ReplaceAll(command, "{{group}}", group)
        command = strings.ReplaceAll(command, "{{arcEnabled}}", strconv.FormatBool(arcEnabled))
        command = strings.ReplaceAll(command, "{{do}}", strconv.FormatBool(digitalOcean))
        command = strings.ReplaceAll(command, "{{zone}}", ssl)
        command = strings.ReplaceAll(command, "{{dnsRG}}", dnsRG)
        command = strings.ReplaceAll(command, "{{mi}}", managedIdentityID)

        // todo - testing
        env := ""

        for _, val := range os.Environ() </span><span class="cov0" title="0">{
                if strings.HasPrefix(val, "AKDC_") </span><span class="cov0" title="0">{
                        split := strings.SplitN(val, "=", 2)
                        if len(split) == 2 </span><span class="cov0" title="0">{
                                val = strings.ReplaceAll(split[1], "\n", "")
                                val = strings.ReplaceAll(val, "\"", "\\\"")
                                line := fmt.Sprintf("  echo 'export %s=\"", split[0])
                                line += val
                                line += "\"'\n"

                                env += line
                        }</span>
                }
        }
        <span class="cov0" title="0">command = strings.ReplaceAll(command, "{{environment}}", env)

        os.WriteFile("cluster-"+cluster+".sh", []byte(command), 0644)</span>
}

// create Azure VM
func createVM(cluster string) string <span class="cov0" title="0">{
        cfmt.Info("Creating Azure VM: ", cluster)

        command := "az vm create \\\n"
        command += " -g " + group + " \\\n"
        command += " -l " + location + " \\\n"
        command += " -n " + cluster + " \\\n"
        command += " --admin-username akdc \\\n"

        if managedIdentityID != "" </span><span class="cov0" title="0">{
                command += " --assign-identity " + managedIdentityID + "\\\n"
        }</span>

        <span class="cov0" title="0">command += " --size " + sku + " \\\n"
        command += " --image Canonical:0001-com-ubuntu-server-focal:20_04-lts-gen2:latest \\\n"
        command += " --os-disk-size-gb 128 \\\n"
        command += " --storage-sku Premium_LRS \\\n"
        command += " --generate-ssh-keys \\\n"
        command += " --public-ip-sku Standard \\\n"
        command += " --custom-data cluster-" + cluster + ".sh \\\n"
        command += " --query publicIpAddress \\\n"
        command += " -o tsv"

        ip, err := boa.ShellExecOut(command, verbose)
        ip = strings.TrimSpace(ip)

        if err != nil || ip == "" </span><span class="cov0" title="0">{
                cfmt.FAppendToFile("failed.log", cluster+"\n")
                return ""
        }</span>

        // cfmt.Info("VM Created: ", cluster)
        // fmt.Println(cluster, ip)
        <span class="cov0" title="0">cfmt.FAppendToFile("ips", fmt.Sprintf("%s\t%s\n", cluster, ip))

        // cfmt.Info("Deleting NSG: ", cluster)
        command = "az network nsg rule delete -g " + group + " --nsg-name " + cluster + "NSG -o table --name default-allow-ssh"
        boa.ShellExecOut(command, false)

        // cfmt.Info("Creating SSH Rule: ", cluster)

        command = "az network nsg rule create \\\n"
        command += "-g " + group + " \\\n"
        command += "--nsg-name " + cluster + "NSG \\\n"
        command += "-n SSH-http \\\n"
        command += "--description \"SSH http https\" \\\n"
        command += "--destination-port-ranges 2222 80 443 \\\n"
        command += "--protocol tcp \\\n"
        command += "--access allow \\\n"
        command += "--priority 1202 -o table"
        boa.ShellExecOut(command, false)

        return ip</span>
}

// get GitOps template
func getConfigJson(cluster string) []byte <span class="cov0" title="0">{
        region := cluster
        zone := cluster
        district := cluster

        cols := strings.Split(cluster, "-")

        if len(cols) &gt; 0 </span><span class="cov0" title="0">{
                region = cols[0]

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        zone = strings.Join(cols[0:2], "-")
                }</span>

                <span class="cov0" title="0">if len(cols) &gt; 2 </span><span class="cov0" title="0">{
                        district = strings.Join(cols[0:3], "-")
                }</span>
        }

        <span class="cov0" title="0">json := boa.ReadTextFileFromBoaDir("gitops-config.templ")

        if json == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // replace template values
        <span class="cov0" title="0">json = strings.Replace(json, "{{cluster}}", cluster, -1)
        json = strings.Replace(json, "{{region}}", region, -1)
        json = strings.Replace(json, "{{district}}", district, -1)
        json = strings.Replace(json, "{{zone}}", zone, -1)
        json = strings.Replace(json, "{{domain}}", ssl, -1)

        return []byte(json)</span>
}

// add a target to GitOps
func addTargetE(cluster string) error <span class="cov0" title="0">{
        // only run if --gitops specified
        if !(gitops || gitopsOnly) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // read the config.json file
        <span class="cov0" title="0">json := getConfigJson(cluster)

        // make sure the json is valid
        if json == nil || len(json) &lt; 3 || strings.Contains(string(json), "{{") </span><span class="cov0" title="0">{
                return cfmt.ErrorE("unable to read gitops-config.templ")
        }</span>

        <span class="cov0" title="0">return addTargetWorkerE(cluster, json)</span>
}

// add a target to GitOps
func addTargetWorkerE(cluster string, json []byte) error <span class="cov0" title="0">{
        configDir := "config"

        // add the targets
        if len(json) &gt; 0 &amp;&amp; !strings.Contains(string(json), "{{") </span><span class="cov0" title="0">{
                // make sure the dirs exist
                if _, err := os.Stat(configDir); err == nil </span><span class="cov0" title="0">{
                        // add cluster to the dirs
                        configDir = filepath.Join(configDir, cluster)

                        // create the directory
                        if err := boa.ShellExecE("mkdir -p " + configDir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // write config.json to each dir
                        <span class="cov0" title="0">configDir = filepath.Join(configDir, "config.json")

                        if _, err := os.Stat(configDir); err != nil </span><span class="cov0" title="0">{
                                if err := os.WriteFile(configDir, json, 0644); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov0" title="0">if len(clusters) &gt; 1 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">return updateGitOpsRepoE()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// update the GitOps repo with changes
func updateGitOpsRepoE() error <span class="cov0" title="0">{
        // if there were repo changes
        if res, _ := boa.ShellExecOut("git status -s", false); res != "" </span><span class="cov0" title="0">{
                // pull to avoid conflicts
                if _, err := boa.ShellExecOut("git pull", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update the repo
                <span class="cov0" title="0">if _, err := boa.ShellExecOut("git add config", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := boa.ShellExecOut("git commit -am 'flt create'", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // push the changes
                <span class="cov0" title="0">if _, err := boa.ShellExecOut("git push", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

// DeleteCmd deletes a cluster and DNS entry
var DeleteCmd = &amp;cobra.Command{
        Use:               "delete",
        Short:             "Delete an Azure Resource Group and associated Azure DNS record",
        Args:              cobra.ExactValidArgs(1),
        ValidArgsFunction: validArgsFleetDelete,
        RunE:              runFleetDeleteE,
}

// run kic fleet delete command
func runFleetDeleteE(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // check if resource group exists
        res, _ := boa.ShellExecOut(fmt.Sprintf("az group exists -n %s", args[0]), false)

        if strings.TrimSpace(res) == "true" </span><span class="cov0" title="0">{
                fmt.Println("Deleting Resource Group")
                boa.ShellExecE(fmt.Sprintf("az group delete -g %s --yes --no-wait", args[0]))
        }</span>

        // delete the DNS record (if exists)
        <span class="cov0" title="0">boa.ShellExecE("flt dns delete " + args[0])

        return nil</span>
}

// validate kic fleet delete args
func validArgsFleetDelete(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        // don't use the defaultIPs
        if _, err := os.Stat("ips"); err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // only one argument
        <span class="cov0" title="0">if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // suggest from the ips file
        <span class="cov0" title="0">if ips, err := boa.ReadHostIPs(""); err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span> else<span class="cov0" title="0"> {
                return ips, cobra.ShellCompDirectiveNoFileComp
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var DnsCmd = &amp;cobra.Command{
        Use:   "dns",
        Short: "DNS Commands",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(DnsCmd, "add", "Add a DNS entry", fltDnsAddScript())
        boa.AddScriptCommand(DnsCmd, "delete", "Delete a DNS entry", fltDnsDeleteScript())
        boa.AddScriptCommand(DnsCmd, "list", "List DNS entries", fltDnsListScript())
        boa.AddScriptCommand(DnsCmd, "show", "Get a DNS entry by host name", fltDnsShowScript())
}</span>

func fltDnsAddScript() string <span class="cov8" title="1">{

        return `
if ! az account show -o table &gt; /dev/null
then
    echo "Please login to Azure"
    exit 0
fi

if [ "$AKDC_DNS_RG" = "" ]
then
    echo "Please export AKDC_DNS_RG"
    exit 0
fi

if [ "$AKDC_SSL" = "" ]
then
    echo "Please export AKDC_SSL"
    exit 0
fi

host=$1
pip=$2

if [ "$host" = "" ] || [ "$pip" = "" ]
then
  echo "Usage: flt dns add hostName ipAddress"
  exit 0
fi

# get the old IP
old_ip=$(az network dns record-set a list \
--query "[?name=='$host'].{IP:aRecords}" \
--resource-group "$AKDC_DNS_RG" \
--zone-name "$AKDC_SSL" \
-o json | jq -r '.[].IP[].ipv4Address' | tail -n1)

# delete old DNS entry if exists
if [ "$old_ip" != "" ] &amp;&amp; [ "$old_ip" != "$pip" ]
then
  echo "Deleting old IP: $old_ip"
  # delete the old DNS entry
  az network dns record-set a remove-record \
  -g "$AKDC_DNS_RG" \
  -z "$AKDC_SSL" \
  -n "$host" \
  -a "$old_ip" -o table
fi

if [ "$old_ip" != "$pip" ]
then
  echo "Adding host: $host"
  # create DNS record
  az network dns record-set a add-record \
  -g "$AKDC_DNS_RG" \
  -z "$AKDC_SSL" \
  -n "$host" \
  -a "$pip" \
  --ttl 10 -o table
fi

`
}</span>

func fltDnsDeleteScript() string <span class="cov8" title="1">{

        return `
if ! az account show -o table &gt; /dev/null
then
    echo "Please login to Azure"
    exit 0
fi

if [ "$AKDC_DNS_RG" = "" ]
then
    echo "Please export AKDC_DNS_RG"
    exit 0
fi

if [ "$AKDC_SSL" = "" ]
then
    echo "Please export AKDC_SSL"
    exit 0
fi

host=$1

if [ "$host" = "" ]
then
    echo "Usage: flt dns delete hostName"
    exit 0
fi

if [ "$AKDC_DNS_RG" = "" ]
then
    echo "AKDC_DNS_RG must be set"
    exit 0
fi

if [ "$AKDC_SSL" = "" ]
then
    echo "AKDC_SSL must be set"
    exit 0
fi

echo "Deleting DNS for $host"

# delete the old DNS entry
az network dns record-set a delete \
-g "$AKDC_DNS_RG" \
-z "$AKDC_SSL" \
-n "$host" \
--yes \
-o table

`
}</span>

func fltDnsListScript() string <span class="cov8" title="1">{

        return `
if ! az account show -o table &gt; /dev/null
then
    echo "Please login to Azure"
    exit 0
fi

if [ "$AKDC_DNS_RG" = "" ]
then
    echo "Please export AKDC_DNS_RG"
    exit 0
fi

if [ "$AKDC_SSL" = "" ]
then
    echo "Please export AKDC_SSL"
    exit 0
fi

az network dns record-set a list -g "$AKDC_DNS_RG" -z "$AKDC_SSL" --query '[].name' -o tsv | sort

`
}</span>

func fltDnsShowScript() string <span class="cov8" title="1">{

        return `
if ! az account show -o table &gt; /dev/null
then
    echo "Please login to Azure"
    exit 0
fi

if [ "$AKDC_DNS_RG" = "" ]
then
    echo "Please export AKDC_DNS_RG"
    exit 0
fi

if [ "$AKDC_SSL" = "" ]
then
    echo "Please export AKDC_SSL"
    exit 0
fi

host=$1

if [ "$host" = "" ]
then
    echo "Usage: flt dns get hostName"
    exit 0
fi

if ! az account show -o table &gt; /dev/null
then
    echo "Please login to Azure"
    exit 0
fi

# delete the old DNS entry
az network dns record-set a show \
-g "$AKDC_DNS_RG" \
-z "$AKDC_SSL" \
-n "$host"

`
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// execCmd runs a bash command on each server
var ExecCmd = &amp;cobra.Command{
        Use:   "exec",
        Short: "Execute a bash command on each server",
        Args:  cobra.MinimumNArgs(1),
        RunE:  runFleetExecE,
}

func init() <span class="cov8" title="1">{
        ExecCmd.Flags().StringVarP(&amp;grep, "grep", "g", "", "grep conditional to filter by host")
}</span>

// run kic fleet exec command
func runFleetExecE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        command := fmt.Sprintf("%s", args)

        // command will have []
        if len(command) &lt; 3 </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Usage: flt exec bashCommand")
        }</span>

        // remove []
        <span class="cov8" title="1">command = command[1 : len(command)-1]

        return (boa.ExecClusters(command, grep))</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"
        "kic/cmd/targets"

        "github.com/spf13/cobra"
)

var (
        FleetCmd = &amp;cobra.Command{
                Use:   "flt",
                Short: "Retail Edge CLI",
                Long:  "Retail Edge CLI\n\n  A CLI for automating many Kubernetes fleet tasks",
        }

        // option variable
        grep string
)

func LoadCommands(parent *cobra.Command) *cobra.Command <span class="cov8" title="1">{
        boa.AddCommandIfNotExist(parent, AzCmd)
        boa.AddCommandIfNotExist(parent, CheckCmd)
        boa.AddCommandIfNotExist(parent, CreateCmd)
        boa.AddCommandIfNotExist(parent, DeleteCmd)
        boa.AddCommandIfNotExist(parent, DnsCmd)
        boa.AddCommandIfNotExist(parent, ExecCmd)
        boa.AddCommandIfNotExist(parent, ListCmd)
        boa.AddCommandIfNotExist(parent, SshCmd)
        boa.AddCommandIfNotExist(parent, targets.TargetsCmd)

        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("env", "List the environment variables", "env | grep AKDC | sort"))

        boa.AddCommandIfNotExist(parent, boa.CreateFltCommand("curl", "curl the specified endpoint on each cluster", "", "curl"))
        boa.AddCommandIfNotExist(parent, boa.CreateFltCommand("patch", "Run a patch command on each cluster", "", "patch"))
        boa.AddCommandIfNotExist(parent, boa.CreateFltCommand("pull", "Git pull the akdc repo", "", "pull"))
        boa.AddCommandIfNotExist(parent, boa.CreateFltCommand("sync", "Sync (reconcile) flux on each cluster", "", "sync"))

        if az := boa.GetCommandByUse(parent, "az"); az != nil </span><span class="cov8" title="1">{
                boa.AddCommandIfNotExist(az, boa.CreateFltCommand("arc-token", "Get Arc token from each cluster", "", "arc-token"))
        }</span>

        // add tab completion to flt check app
        <span class="cov8" title="1">if chk := boa.GetCommandByUse(parent, "check"); chk != nil </span><span class="cov8" title="1">{
                if app := boa.GetCommandByUse(chk, "app"); app != nil </span><span class="cov8" title="1">{
                        app.ValidArgsFunction = validArgsFleetCheckApp
                }</span>
        }

        <span class="cov8" title="1">return parent</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "strings"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List the clusters in the fleet",
        RunE:  runFleetList,
}

func init() <span class="cov8" title="1">{
        ListCmd.Flags().StringVarP(&amp;grep, "grep", "g", "", "grep conditional to filter by host")
}</span>

// run the kic fleet list command
func runFleetList(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfmt.Info("Clusters in the fleet")
        fmt.Println()

        hostIPs, err := boa.ReadHostIPs("")

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, line := range hostIPs </span><span class="cov0" title="0">{
                cols := strings.Split(line, "\t")

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Print(cols[0])
                        if len(cols[0]) &lt; 30 </span><span class="cov0" title="0">{
                                fmt.Print(strings.Repeat(" ", 30-len(cols[0])))
                        }</span>
                        <span class="cov0" title="0">fmt.Println(cols[1])</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(line)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// NewAppCmd creates a new application
var NewAppCmd = &amp;cobra.Command{
        Use:   "new",
        Short: "Create a new application",
}

// NewDotnetAppCmd creates a new dotnet application
var NewDotNetAppCmd = &amp;cobra.Command{
        Use:   "dotnet",
        Short: "Create a new dotnet 6 application",
}

func init() <span class="cov8" title="1">{
        NewAppCmd.AddCommand(NewDotNetAppCmd)
        boa.AddScriptCommand(NewDotNetAppCmd, "webapi", "Create a new dotnet WebAPI", fltDotnetWebapiScript())
        boa.AddScriptCommand(NewDotNetAppCmd, "console", "Create a new dotnet console application", fltDotnetConsoleScript())
}</span>

func fltDotnetWebapiScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# update the app name if a valid name
export APP_NAME=$1
export APP_LOWER=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')

if [[ "$APP_NAME" =~ ^[A-Z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]+$ ]]
then
    if [ -d "$APP_LOWER" ]
    then
        echo "Directory $APP_LOWER already exists"
        exit 1
    fi

    git pull
    git clone https://github.com/retaildevcrews/dotnet-webapi-template "$APP_LOWER"
    cd "$APP_LOWER" || exit

    rm -rf .devcontainer
    rm -rf .git
    rm -rf .github
    rm -f .gitignore
    rm -f LICENSE
    rm -f curl.sh

    mv src/csapp.csproj "src/$APP_LOWER.csproj"

    sed -i "s/csapp/$APP_LOWER/g" .kic/commands/app/build
    sed -i "s/csapp/$APP_LOWER/g" .kic/commands/app/deploy
    sed -i "s/cd \"\$REPO_BASE\" || exit//g" .kic/commands/app/build
    sed -i "s~deploy/apps~apps~g" autogitops/autogitops.json
    sed -i "s/csapp/$APP_LOWER/g" Dockerfile
    find . -name '*.*' -type f -exec sed -i "s/CSApp/$APP_NAME/g" {} \;
    find . -name '*.*' -type f -exec sed -i "s/csapp/$APP_LOWER/g" {} \;
    dotnet restore src

    git pull
    git add .
    git commit -m "added testapp"
else
    echo "Invalid App Name $1"
fi

`
}</span>

func fltDotnetConsoleScript() string <span class="cov8" title="1">{
        return "echo \"not implemented\""
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"
        "kic/boa/cfmt"
        "strings"

        "github.com/spf13/cobra"
)

var (
        // sshCmd opens an ssh terminal on a cluster
        SshCmd = &amp;cobra.Command{
                Use:   "ssh",
                Short: "Open an SSH shell to the cluster",
                Args:  cobra.ExactValidArgs(1),

                ValidArgsFunction: validArgsFleetSsh,

                RunE: runFleetSsh,
        }
)

// run kic fleet ssh command
func runFleetSsh(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // get the ip from the ips file
        hostIPs, err := boa.ReadHostIPs(args[0])

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ip := args[0]

        // try to lookup partial DNS name
        if len(hostIPs) &gt; 0 </span><span class="cov0" title="0">{
                ip = hostIPs[len(hostIPs)-1]
                cols := strings.Split(ip, "\t")

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        ip = strings.TrimSpace(cols[1])
                }</span>
        }

        <span class="cov0" title="0">if ip != "" </span><span class="cov0" title="0">{
                boa.ShellExecE("ssh -p 2222 -o \"StrictHostKeyChecking=no\" akdc@" + ip)
        }</span> else<span class="cov0" title="0"> {
                cfmt.ErrorE("unable to find host or IP")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validate kic fleet ssh arg
func validArgsFleetSsh(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        hostIPs, err := boa.ReadHostIPs("")

        if err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // only one arg
        <span class="cov0" title="0">if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // sugest from the ips or defaultIPs file
        <span class="cov0" title="0">return hostIPs, cobra.ShellCompDirectiveNoFileComp</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kic

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var BuildCmd = &amp;cobra.Command{
        Use:   "build",
        Short: "Build local apps",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(BuildCmd, "imdb", "Build and deploy the IMDb reference app to the local cluster", kicBuildImdbScript())
        boa.AddScriptCommand(BuildCmd, "webv", "Build and deploy WebValidate to the local cluster", kicBuildWebvScript())
}</span>

func kicBuildImdbScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -d /workspaces/imdb-app ]; then echo "/workspaces/imdb-app directory not found. Please clone the imdb-app repo to /workspaces"; exit 1; fi
if [ ! -d ./deploy ]; then echo "./deploy directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv ]; then echo "./deploy/webv directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/imdb ]; then echo "./deploy/imdb directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/imdb-local ]; then echo "./deploy/imdb-local directory not found. Please cd to an appropriate directory"; exit 1; fi

# delete webv and imdb
kubectl delete -f deploy/webv --ignore-not-found=true
kubectl delete -f deploy/imdb --ignore-not-found=true

# build and push the local image
docker build /workspaces/imdb-app -t k3d-registry.localhost:5500/imdb-app:local
docker push k3d-registry.localhost:5500/imdb-app:local

# wait for delete to finish
kubectl wait pod -l app=webv -n imdb --for delete --timeout=30s
kubectl wait pod -l app=imdb -n imdb --for delete --timeout=30s

# deploy local app and re-deploy webv
kubectl apply -f deploy/imdb-local
kubectl wait pod -l app=imdb -n imdb --for condition=ready --timeout=30s
kubectl apply -f deploy/webv
kubectl wait pod -l app=webv -n imdb --for condition=ready --timeout=30s

# show status and curl results
kubectl get po -n imdb
http localhost:30080/version

`
}</span>

func kicBuildWebvScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -d /workspaces/webvalidate ]; then echo "/workspaces/webvalidate directory not found. Please clone the webvalidate repo to /workspaces"; exit 1; fi
if [ ! -d ./deploy ]; then echo "./deploy directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv ]; then echo "./deploy/webv directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv-local ]; then echo "./deploy/webv-local directory not found. Please cd to an appropriate directory"; exit 1; fi

# delete local deployment
kubectl delete -f deploy/webv --ignore-not-found=true

# build and push the local docker image
docker build /workspaces/webvalidate -t k3d-registry.localhost:5500/webv:local
docker push k3d-registry.localhost:5500/webv:local

# create deployment from webv-local
kubectl wait pod -l app=webv -n imdb --for delete --timeout=30s
kubectl apply -f deploy/webv-local
kubectl wait pod -l app=webv -n imdb --for condition=ready --timeout=30s

# show pods and curl results
kubectl get pods -n imdb
"$(dirname "${BASH_SOURCE[0]}")/../check/webv"

`
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kic

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var CheckCmd = &amp;cobra.Command{
        Use:   "check",
        Short: "Check status on the local cluster",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(CheckCmd, "all", "Run all status checks on the local cluster", kicCheckAllScript())
        boa.AddScriptCommand(CheckCmd, "heartbeat", "Check heartbeat status on the local cluster", kicCheckHeartbeatScript())
        boa.AddScriptCommand(CheckCmd, "imdb", "Check IMDb reference app status on the local cluster", kicCheckImdbScript())
        boa.AddScriptCommand(CheckCmd, "webv", "Check WebV status on the local cluster", kicCheckWebvScript())
        boa.AddScriptCommand(CheckCmd, "grafana", "Check Grafana status on the local cluster", kicCheckGrafanaScript())
        boa.AddScriptCommand(CheckCmd, "prometheus", "Check Prometheus status on the local cluster", kicCheckPrometheusScript())
}</span>

func kicCheckAllScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

echo "Checking Heartbeat"
kic check heartbeat

echo "Checking IMDb"
kic check imdb

echo "Checking WebV"
kic check webv

echo "Checking Grafana"
kic check grafana

echo "Checking Prometheus"
kic check prometheus

`
}</span>

func kicCheckHeartbeatScript() string <span class="cov8" title="1">{
        return "http localhost:31080/heartbeat/17"
}</span>

func kicCheckImdbScript() string <span class="cov8" title="1">{
        return "http localhost:30080/version"
}</span>

func kicCheckWebvScript() string <span class="cov8" title="1">{

        return "kubectl exec -it jumpbox -- http webv.imdb.svc.cluster.local:8080/version"
}</span>

func kicCheckGrafanaScript() string <span class="cov8" title="1">{

        return "http localhost:32000/healthz"
}</span>

func kicCheckPrometheusScript() string <span class="cov8" title="1">{

        return "http localhost:30000"
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kic

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var ClusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "k3d cluster commands",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(ClusterCmd, "rebuild", "Create and bootstrap a local k3d cluster and deploy the apps", kicClusterRebuildScript())
        boa.AddScriptCommand(ClusterCmd, "create", "Create a new local k3d cluster", kicClusterCreateScript())
        boa.AddScriptCommand(ClusterCmd, "delete", "Delete the k3d cluster", kicClusterDeleteScript())
        boa.AddScriptCommand(ClusterCmd, "jumpbox", "Deploy a 'jumpbox' to the local k3d cluster", kicClusterJumpboxScript())
        boa.AddScriptCommand(ClusterCmd, "clean", "Remove the apps from the local k3d cluster", kicClusterCleanScript())
        boa.AddScriptCommand(ClusterCmd, "deploy", "Deploy the apps to the local k3d cluster", kicClusterDeployScript())
}</span>

func kicClusterCreateScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -f "$REPO_BASE/.devcontainer/k3d.yaml" ]; then echo "File not found - \"$REPO_BASE\"/.devcontainer/k3d.yaml"; exit 1; fi

kic cluster delete

echo ""
echo "Creating cluster ..."

k3d cluster create \
    --registry-use k3d-registry.localhost:5500 \
    --k3s-server-arg '--no-deploy=traefik' \
    --config "$REPO_BASE/.devcontainer/k3d.yaml"

`
}</span>

func kicClusterDeleteScript() string <span class="cov8" title="1">{

        return "k3d cluster delete"
}</span>

func kicClusterJumpboxScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

kubectl delete pod jumpbox --ignore-not-found=true
kubectl run jumpbox --image=ghcr.io/cse-labs/jumpbox --restart=Always

`
}</span>

func kicClusterCleanScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

kubectl delete ns imdb --ignore-not-found=true
kubectl delete pod jumpbox --ignore-not-found=true

`
}</span>

func kicClusterDeployScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -d ./deploy ]; then echo "./deploy directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv ]; then echo "./deploy/webv directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/imdb ]; then echo "./deploy/imdb directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/bootstrap ]; then echo "./deploy/bootstrap directory not found. Please cd to an appropriate directory"; exit 1; fi

# create namespace
kubectl apply -f deploy

# deploy imdb reference app
kubectl apply -f deploy/imdb

# deploy heartbeat, prometheus, grafana, and fluent bit
kubectl apply -f deploy/bootstrap
kubectl apply -R -f deploy/bootstrap

"$(dirname "${BASH_SOURCE[0]}")/jumpbox"

# deploy WebV after the app starts
kubectl wait pod -l app=imdb -n imdb --for condition=ready --timeout=60s

kubectl apply -f deploy/webv

`
}</span>

func kicClusterRebuildScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

kic cluster create
kic cluster deploy

`
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kic

import (
        "kic/boa"
        "kic/cmd/targets"
        "kic/cmd/test"

        "github.com/spf13/cobra"
)

var KicCmd = &amp;cobra.Command{
        Use:   "kic",
        Short: "Kubernetes in Codespaces CLI",
        Long:  "Kubernetes in Codespaces CLI\n\n  A CLI for automating many Kubernetes inner-loop tasks",
}

func LoadCommands(parent *cobra.Command) *cobra.Command <span class="cov8" title="1">{

        boa.AddCommandIfNotExist(parent, BuildCmd)
        boa.AddCommandIfNotExist(parent, CheckCmd)
        boa.AddCommandIfNotExist(parent, ClusterCmd)
        boa.AddCommandIfNotExist(parent, targets.TargetsCmd)
        boa.AddCommandIfNotExist(parent, test.TestCmd)

        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("env", "List the environment variables", kicEnvScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("events", "Get all Kubernetes events on the local dev cluster", kicEventsScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("pods", "Get all pods on the local dev cluster", kicPodsScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("svc", "Get all services on the local dev cluster", kicSvcScript()))

        return parent
}</span>

func kicEnvScript() string <span class="cov8" title="1">{

        return "env | grep AKDC | sort"
}</span>

func kicEventsScript() string <span class="cov8" title="1">{

        return "kubectl get events --all-namespaces --sort-by='.metadata.creationTimestamp'"
}</span>

func kicPodsScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

hdrsort()
{
    read -r
    printf "%s\\n" "$REPLY"
    sort
}

kubectl get pods -A | hdrsort

`
}</span>

func kicSvcScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

hdrsort()
{
    read -r
    printf "%s\\n" "$REPLY"
    sort
}

kubectl get svc -A | hdrsort

`
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kivm

import (
        "kic/boa"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var CheckCmd = &amp;cobra.Command{
        Use:   "check",
        Short: "Check status on the local cluster",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(CheckCmd, "flux", "Check Flux status on the local cluster", kivmCheckFluxScript())
        boa.AddScriptCommand(CheckCmd, "heartbeat", "Check heartbeat status on the local cluster", kivmCheckHeartbeatScript())
        boa.AddScriptCommand(CheckCmd, "logs", "Check Logs on the local cluster", kivmCheckLogsScript())
        boa.AddScriptCommand(CheckCmd, "imdb", "Check IMDb app status on the local cluster", kivmCheckImdbScript())
        boa.AddScriptCommand(CheckCmd, "setup", "Check setup progress on the local cluster", kivmCheckSetupScript())
}</span>

func kivmCheckFluxScript() string <span class="cov8" title="1">{
        return "flux get kustomization"
}</span>

func kivmCheckLogsScript() string <span class="cov8" title="1">{
        return "cat /var/log/cloud-init-output.log"
}</span>

func kivmCheckSetupScript() string <span class="cov8" title="1">{
        return "cat ~/status"
}</span>

func kivmCheckHeartbeatScript() string <span class="cov8" title="1">{
        return getUrl("/heartbeat/17")
}</span>

func kivmCheckImdbScript() string <span class="cov8" title="1">{
        return getUrl("/version")
}</span>

func getUrl(path string) string <span class="cov8" title="1">{
        ssl := os.Getenv("AKDC_SSL")
        fqdn := os.Getenv("AKDC_FQDN")

        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>

        <span class="cov8" title="1">cmd := fqdn + path

        if ssl == "" </span><span class="cov0" title="0">{
                cmd = "http http://" + cmd
        }</span> else<span class="cov8" title="1"> {
                cmd = "http https://" + cmd
        }</span>

        <span class="cov8" title="1">return cmd</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kivm

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var ClusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "k3d cluster commands",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(ClusterCmd, "reset", "Create and bootstrap a local k3d cluster and deploy the apps", kivmClusterResetScript())
        boa.AddScriptCommand(ClusterCmd, "delete", "Delete the k3d cluster", kivmClusterDeleteScript())
        boa.AddScriptCommand(ClusterCmd, "jumpbox", "Deploy a 'jumpbox' to the local k3d cluster", kivmClusterJumpboxScript())
}</span>

func kivmClusterDeleteScript() string <span class="cov8" title="1">{

        return "k3d cluster delete"
}</span>

func kivmClusterJumpboxScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

kubectl delete pod jumpbox --ignore-not-found=true
kubectl run jumpbox --image=ghcr.io/cse-labs/jumpbox --restart=Always

`
}</span>

func kivmClusterResetScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

kivm cluster delete

echo ""
echo "Creating cluster ..."

### todo - check az login

cd $HOME/gitops/vm/setup || exit

./akdc-pre-k8s.sh
./k8s-setup.sh
./akdc-pre-flux.sh
./flux-setup.sh
./akdc-pre-arc.sh
./arc-setup.sh
./akdc-post.sh

`
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package kivm

import (
        "kic/boa"
        "kic/cmd/test"

        "github.com/spf13/cobra"
)

var KivmCmd = &amp;cobra.Command{
        Use:   "kivm",
        Short: "Kubernetes in VMs CLI",
        Long:  "Kubernetes in VMs CLI\n\n  A CLI for automating many Kubernetes fleet cluster tasks",
}

func LoadCommands(parent *cobra.Command) *cobra.Command <span class="cov8" title="1">{
        boa.AddCommandIfNotExist(parent, CheckCmd)
        boa.AddCommandIfNotExist(parent, ClusterCmd)
        boa.AddCommandIfNotExist(parent, test.TestCmd)

        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("az-login", "Log in to Azure using Managed Identity", kivmAzLoginScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("env", "List the environment variables", kivmEnvScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("events", "Get all Kubernetes events on the local dev cluster", kivmEventsScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("pods", "Get all pods on the local dev cluster", kivmPodsScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("pull", "Pull latest git repos", kivmPullScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("svc", "Get all services on the local dev cluster", kivmSvcScript()))
        boa.AddCommandIfNotExist(parent, boa.CreateScriptCommand("sync", "Force Flux to sync (reconcile) to the local cluster", kivmSyncScript()))

        return parent
}</span>

func kivmPodsScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

hdrsort()
{
    read -r
    printf "%s\\n" "$REPLY"
    sort
}

kubectl get pods -A | hdrsort

`
}</span>

func kivmAzLoginScript() string <span class="cov8" title="1">{
        return "az login --identity -o table"
}</span>

func kivmEnvScript() string <span class="cov8" title="1">{

        return "env | grep AKDC | sort"
}</span>

func kivmEventsScript() string <span class="cov8" title="1">{
        return "kubectl get events --all-namespaces --sort-by='.metadata.creationTimestamp'"
}</span>

func kivmPullScript() string <span class="cov8" title="1">{
        return "git -C $HOME/gitops pull"
}</span>

func kivmSvcScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

hdrsort()
{
    read -r
    printf "%s\\n" "$REPLY"
    sort
}

kubectl get svc -A | hdrsort

`
}</span>

func kivmSyncScript() string <span class="cov8" title="1">{
        return "flux reconcile source git gitops &amp;&amp; kubectl get pods -A"
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

// special version of kic for the kubecon hands-on labs

package kubekic

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var BuildCmd = &amp;cobra.Command{
        Use:   "build",
        Short: "Build local apps",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(BuildCmd, "imdb", "Build and deploy the IMDb reference app to the local cluster", kicBuildImdbScript())
        boa.AddScriptCommand(BuildCmd, "webv", "Build and deploy WebValidate to the local cluster", kicBuildWebvScript())
}</span>

func kicBuildImdbScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -d /workspaces/imdb-app ]; then echo "/workspaces/imdb-app directory not found. Please clone the imdb-app repo to /workspaces"; exit 1; fi
if [ ! -d ./deploy ]; then echo "./deploy directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv ]; then echo "./deploy/webv directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/imdb ]; then echo "./deploy/imdb directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/imdb-local ]; then echo "./deploy/imdb-local directory not found. Please cd to an appropriate directory"; exit 1; fi

# delete webv and imdb
kubectl delete -f deploy/webv --ignore-not-found=true
kubectl delete -f deploy/imdb --ignore-not-found=true

# build and push the local image
docker build /workspaces/imdb-app -t k3d-registry.localhost:5500/imdb-app:local
docker push k3d-registry.localhost:5500/imdb-app:local

# wait for delete to finish
kubectl wait pod -l app=webv -n imdb --for delete --timeout=30s
kubectl wait pod -l app=imdb -n imdb --for delete --timeout=30s

# deploy local app and re-deploy webv
kubectl apply -f deploy/imdb-local
kubectl wait pod -l app=imdb -n imdb --for condition=ready --timeout=30s
kubectl apply -f deploy/webv
kubectl wait pod -l app=webv -n imdb --for condition=ready --timeout=30s

# show status and curl results
kubectl get po -n imdb
http localhost:30080/version

`
}</span>

func kicBuildWebvScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -d /workspaces/webvalidate ]; then echo "/workspaces/webvalidate directory not found. Please clone the webvalidate repo to /workspaces"; exit 1; fi
if [ ! -d ./deploy ]; then echo "./deploy directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv ]; then echo "./deploy/webv directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv-local ]; then echo "./deploy/webv-local directory not found. Please cd to an appropriate directory"; exit 1; fi

# delete local deployment
kubectl delete -f deploy/webv --ignore-not-found=true

# build and push the local docker image
docker build /workspaces/webvalidate -t k3d-registry.localhost:5500/webv:local
docker push k3d-registry.localhost:5500/webv:local

# create deployment from webv-local
kubectl wait pod -l app=webv -n imdb --for delete --timeout=30s
kubectl apply -f deploy/webv-local
kubectl wait pod -l app=webv -n imdb --for condition=ready --timeout=30s

# show pods and curl results
kubectl get pods -n imdb
"$(dirname "${BASH_SOURCE[0]}")/../check/webv"

`
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

// special version of kic for the kubecon hands-on labs

package kubekic

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var CheckCmd = &amp;cobra.Command{
        Use:   "check",
        Short: "Check status on the local cluster",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(CheckCmd, "all", "Run all status checks on the local cluster", kicCheckAllScript())
        boa.AddScriptCommand(CheckCmd, "heartbeat", "Check heartbeat status on the local cluster", kicCheckHeartbeatScript())
        boa.AddScriptCommand(CheckCmd, "imdb", "Check IMDb reference app status on the local cluster", kicCheckImdbScript())
        boa.AddScriptCommand(CheckCmd, "webv", "Check WebV status on the local cluster", kicCheckWebvScript())
        boa.AddScriptCommand(CheckCmd, "grafana", "Check Grafana status on the local cluster", kicCheckGrafanaScript())
        boa.AddScriptCommand(CheckCmd, "prometheus", "Check Prometheus status on the local cluster", kicCheckPrometheusScript())
}</span>

func kicCheckAllScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

echo "Checking Heartbeat"
kic check heartbeat

echo "Checking IMDb"
kic check imdb

echo "Checking WebV"
kic check webv

echo "Checking Grafana"
kic check grafana

echo "Checking Prometheus"
kic check prometheus

`
}</span>

func kicCheckHeartbeatScript() string <span class="cov8" title="1">{
        return "http localhost:31080/heartbeat/17"
}</span>

func kicCheckImdbScript() string <span class="cov8" title="1">{
        return "http localhost:30080/version"
}</span>

func kicCheckWebvScript() string <span class="cov8" title="1">{

        return "kubectl exec -it jumpbox -- http webv.imdb.svc.cluster.local:8080/version"
}</span>

func kicCheckGrafanaScript() string <span class="cov8" title="1">{

        return "http localhost:32000/healthz"
}</span>

func kicCheckPrometheusScript() string <span class="cov8" title="1">{

        return "http localhost:30000"
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

// special version of kic for the kubecon hands-on labs

package kubekic

import (
        "kic/boa"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var ClusterCmd = &amp;cobra.Command{
        Use:   "cluster",
        Short: "k3d cluster commands",
}

func init() <span class="cov8" title="1">{
        boa.AddScriptCommand(ClusterCmd, "create", "Create a new local k3d cluster", kicClusterCreateScript())
        boa.AddScriptCommand(ClusterCmd, "delete", "Delete the k3d cluster", kicClusterDeleteScript())
        boa.AddScriptCommand(ClusterCmd, "jumpbox", "Deploy a 'jumpbox' to the local k3d cluster", kicClusterJumpboxScript())
        // boa.AddScriptCommand(ClusterCmd, "rebuild", "Create and bootstrap a local k3d cluster and deploy the apps", kicClusterRebuildScript())
        // boa.AddScriptCommand(ClusterCmd, "clean", "Remove the apps from the local k3d cluster", kicClusterCleanScript())
        // boa.AddScriptCommand(ClusterCmd, "deploy", "Deploy the apps to the local k3d cluster", kicClusterDeployScript())
}</span>

func kicClusterCreateScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

# validate directories
if [ ! -f "$REPO_BASE/.devcontainer/k3d.yaml" ]; then echo "File not found - \"$REPO_BASE\"/.devcontainer/k3d.yaml"; exit 1; fi

kic cluster delete

echo ""
echo "Creating cluster ..."

k3d cluster create \
    --registry-use k3d-registry.localhost:5500 \
    --k3s-server-arg '--no-deploy=traefik' \
    --config "$REPO_BASE/.devcontainer/k3d.yaml"

`
}</span>

func kicClusterDeleteScript() string <span class="cov8" title="1">{

        return "k3d cluster delete"
}</span>

func kicClusterJumpboxScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

kubectl delete pod jumpbox --ignore-not-found=true
kubectl run jumpbox --image=ghcr.io/cse-labs/jumpbox --restart=Always

`
}</span>

func kicClusterCleanScript() string <span class="cov0" title="0">{

        return `
#!/bin/bash

kubectl delete ns imdb --ignore-not-found=true
kubectl delete pod jumpbox --ignore-not-found=true

`
}</span>

func kicClusterDeployScript() string <span class="cov0" title="0">{

        return `
#!/bin/bash

# validate directories
if [ ! -d ./deploy ]; then echo "./deploy directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/webv ]; then echo "./deploy/webv directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/imdb ]; then echo "./deploy/imdb directory not found. Please cd to an appropriate directory"; exit 1; fi
if [ ! -d ./deploy/bootstrap ]; then echo "./deploy/bootstrap directory not found. Please cd to an appropriate directory"; exit 1; fi

# create namespace
kubectl apply -f deploy

# deploy imdb reference app
kubectl apply -f deploy/imdb

# deploy heartbeat, prometheus, grafana, and fluent bit
kubectl apply -f deploy/bootstrap
kubectl apply -R -f deploy/bootstrap

"$(dirname "${BASH_SOURCE[0]}")/jumpbox"

# deploy WebV after the app starts
kubectl wait pod -l app=imdb -n imdb --for condition=ready --timeout=60s

kubectl apply -f deploy/webv

`
}</span>

func kicClusterRebuildScript() string <span class="cov0" title="0">{

        return `
#!/bin/bash

kic cluster create
kic cluster deploy

`
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

// special version of kic for the kubecon hands-on labs

package kubekic

import (
        "kic/boa"
        "kic/cmd/test"

        "github.com/spf13/cobra"
)

var KicCmd = &amp;cobra.Command{
        Use:   "kic",
        Short: "Kubernetes in Codespaces CLI",
        Long:  "Kubernetes in Codespaces CLI\n\n  A CLI for automating many Kubernetes inner-loop tasks",
}

func init() <span class="cov8" title="1">{

        KicCmd.AddCommand(BuildCmd)
        KicCmd.AddCommand(CheckCmd)
        KicCmd.AddCommand(ClusterCmd)
        KicCmd.AddCommand(test.TestCmd)
        //KicCmd.AddCommand(targets.TargetsCmd)

        boa.AddScriptCommand(KicCmd, "pods", "Get all pods on the local dev cluster", kicPodsScript())
        boa.AddScriptCommand(KicCmd, "svc", "Get all services on the local dev cluster", kicSvcScript())
        boa.AddScriptCommand(KicCmd, "events", "Get all Kubernetes events on the local dev cluster", kicEventsScript())
        // boa.AddScriptCommand(KicCmd, "env", "List the environment variables", kicEnvScript())
}</span>

func kicPodsScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

hdrsort()
{
    read -r
    printf "%s\\n" "$REPLY"
    sort
}

kubectl get pods -A | hdrsort

`
}</span>

func kicSvcScript() string <span class="cov8" title="1">{

        return `
#!/bin/bash

hdrsort()
{
    read -r
    printf "%s\\n" "$REPLY"
    sort
}

kubectl get svc -A | hdrsort

`
}</span>

func kicEventsScript() string <span class="cov8" title="1">{

        return "kubectl get events --all-namespaces --sort-by='.metadata.creationTimestamp'"
}</span>

func kicEnvScript() string <span class="cov0" title="0">{

        return "env | grep AKDC | sort"
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package cmd

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "kic/cmd/fleet"
        "kic/cmd/kic"
        "kic/cmd/kivm"
        "kic/cmd/kubekic"
        "os"

        "github.com/spf13/cobra"
)

var (
        // set TargetCli [and Version] in build via -ldflags - see Makefile
        TargetCli = "flt"
        Version   = "0.4.1"

        // rootCmd represents the base command
        rootCmd = &amp;cobra.Command{}
)

// initialize the root command
func init() <span class="cov8" title="1">{

        boa.LoadCommands(rootCmd)

        // load the commands based on target
        switch TargetCli </span>{
        case "kic":<span class="cov0" title="0">
                if len(rootCmd.Commands()) == 0 </span><span class="cov0" title="0">{
                        rootCmd = kic.KicCmd
                }</span>

                <span class="cov0" title="0">rootCmd = kic.LoadCommands(rootCmd)</span>
        case "kubekic":<span class="cov0" title="0">
                // not dynamic
                rootCmd = kubekic.KicCmd</span>
        case "kivm":<span class="cov0" title="0">
                if len(rootCmd.Commands()) == 0 </span><span class="cov0" title="0">{
                        rootCmd = kivm.KivmCmd
                }</span>

                <span class="cov0" title="0">rootCmd = kivm.LoadCommands(rootCmd)</span>
        case "flt":<span class="cov8" title="1">
                if len(rootCmd.Commands()) == 0 </span><span class="cov8" title="1">{
                        rootCmd = fleet.FleetCmd
                }</span>

                <span class="cov8" title="1">rootCmd = fleet.LoadCommands(rootCmd)</span>
        default:<span class="cov0" title="0">
                cfmt.ErrorE("unknown CLI")
                os.Exit(1)</span>
        }

        // add version command
        <span class="cov8" title="1">boa.AddScriptCommand(rootCmd, "version", TargetCli+" version", fmt.Sprintf("echo \"%s\"", Version))</span>
}

// execute the root command
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// AddCmd adds a target to GitOps
var AddCmd = &amp;cobra.Command{
        Use:   "add",
        Short: "Add a GitOps target",

        Args: argsTargets,

        RunE: runTargetsAddE,
}

func runTargetsAddE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Error: specify the target to add")
        }</span>

        <span class="cov8" title="1">result := getAutoGitOpsConfigMap()

        if result != nil </span><span class="cov8" title="1">{
                t := result["targets"]

                var nt []interface{}

                found := false

                if t != nil </span><span class="cov8" title="1">{
                        for _, v := range t.([]interface{}) </span><span class="cov8" title="1">{
                                nt = append(nt, v)

                                if v == args[0] </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        nt = append(nt, args[0])
                }</span>

                <span class="cov8" title="1">result["targets"] = nt

                saveAutoGitOpsConfig(result)

                fmt.Println(nt)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// ClearCmd clears the GitOps targets
var ClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear all GitOps targets",
        Args:  argsTargets,
        RunE:  runTargetsClearE,
}

func runTargetsClearE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        result := getAutoGitOpsConfigMap()

        if result != nil </span><span class="cov8" title="1">{
                var nt []interface{}

                result["targets"] = nt

                saveAutoGitOpsConfig(result)

                fmt.Println("targets cleared")

                return nil
        }</span>

        <span class="cov0" title="0">return cfmt.ErrorE("Unable to read targets")</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
)

// DeployCmd adds, commits, and deploys the GitOps targets to the repo
var DeployCmd = &amp;cobra.Command{
        Use:   "deploy",
        Short: "Deploy to the target stores",
        Args:  argsTargets,
        RunE:  runTargetsDeployE,
}

// run targets deploy cmd
func runTargetsDeployE(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // build the commit message from app name
        app, _ := os.Getwd()
        app = filepath.Base(app)

        // make sure repo is up-to-date
        if err := boa.ShellExecE("git pull"); err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("git pull failed")
                return nil
        }</span>

        // make sure the repo is up to date
        <span class="cov0" title="0">res, err := boa.ShellExecOut("git status -s", false)

        if err != nil </span><span class="cov0" title="0">{
                return cfmt.ErrorE(err)
        }</span>

        <span class="cov0" title="0">if res != "" </span><span class="cov0" title="0">{
                // commit and push
                commit := "git commit -am 'Secure Build: " + app + "'"
                if err := boa.ShellExecE(commit); err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("git commit failed")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if err := boa.ShellExecE("git push"); err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("git push failed")
                return nil
        }</span>

        <span class="cov0" title="0">cfmt.Info("updated " + app)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// ListCmd lists the GitOps targets
var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List current targets",
        Args:  argsTargets,
        RunE:  runTargetsListE,
}

func runTargetsListE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        result := getAutoGitOpsConfigMap()

        if result != nil </span><span class="cov8" title="1">{
                if result["targets"] == nil </span><span class="cov0" title="0">{
                        cfmt.Info("targets is empty")
                }</span> else<span class="cov8" title="1"> {
                        cfmt.Info("Targets")
                        fmt.Println(result["targets"])
                }</span>
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov0" title="0"> {
                return cfmt.ErrorE("failed to read autogitops.json")
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// RemoveCmd removes a target from GitOps
var RemoveCmd = &amp;cobra.Command{
        Use:   "remove",
        Short: "Remove a GitOps target",
        Args:  argsTargets,
        RunE:  runTargetsRemoveE,
}

func runTargetsRemoveE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Error: specify the target to remove")
        }</span>

        <span class="cov8" title="1">result := getAutoGitOpsConfigMap()

        if result == nil </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Error: unable to read autogitops.json")
        }</span> else<span class="cov8" title="1"> {
                t := result["targets"]

                if t == nil </span><span class="cov0" title="0">{
                        fmt.Println("targets is empty")
                        return nil
                }</span>

                <span class="cov8" title="1">var nt []interface{}

                for _, v := range t.([]interface{}) </span><span class="cov8" title="1">{
                        if v != args[0] </span><span class="cov8" title="1">{
                                nt = append(nt, v)
                        }</span>
                }

                <span class="cov8" title="1">result["targets"] = nt

                saveAutoGitOpsConfig(result)

                fmt.Println(nt)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "encoding/json"
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
)

var (
        AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "config.json")

        // TargetsCmd contains the GitOps targets commands
        TargetsCmd = &amp;cobra.Command{
                Use:   "targets",
                Short: "Manage GitOps targets",
        }
)

func init() <span class="cov8" title="1">{
        TargetsCmd.AddCommand(AddCmd)
        TargetsCmd.AddCommand(ClearCmd)
        TargetsCmd.AddCommand(ListCmd)
        TargetsCmd.AddCommand(DeployCmd)
        TargetsCmd.AddCommand(RemoveCmd)
}</span>

// args validation for targets commands
func argsTargets(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        return checkForConfigFile()
}</span>

// check for the config file
func checkForConfigFile() error <span class="cov8" title="1">{
        // todo - AGO changed the name of the config file and deprecated autogitops.json in favor of config.json
        //        both still work but config.json is the preferred and future only name
        //        change this back once all the fleets are converted

        // try config.json
        AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "config.json")

        if _, err := os.Stat(AutoGitOpsConfigFile); err != nil </span><span class="cov8" title="1">{
                // try autogitops.json (deprecated)
                AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "autogitops.json")

                if _, err := os.Stat(AutoGitOpsConfigFile); err != nil </span><span class="cov8" title="1">{
                        // set back to preferred
                        AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "config.json")
                        return fmt.Errorf("GitOps file not found - please cd to an app with GitOps setup")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// read config file into map
func getAutoGitOpsConfigMap() map[string]interface{} <span class="cov8" title="1">{
        // check for the config file
        if err := checkForConfigFile(); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // make sure the repo is up to date
        <span class="cov8" title="1">boa.ShellExecOut("git pull", false)

        content, err := os.ReadFile(AutoGitOpsConfigFile)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return nil
        }</span>

        <span class="cov8" title="1">txt := string(content)

        var result map[string]interface{}

        err = json.Unmarshal([]byte(txt), &amp;result)

        if err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("unmarshal json faile")
                fmt.Println(err)
                return nil
        }</span>

        <span class="cov8" title="1">return result</span>
}

// save config file from map
func saveAutoGitOpsConfig(result map[string]interface{}) <span class="cov8" title="1">{
        // check for the config file
        if err := checkForConfigFile(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if val, err := json.MarshalIndent(result, "", "    "); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error saving:", err)
        }</span> else<span class="cov8" title="1"> {
                os.WriteFile(AutoGitOpsConfigFile, val, 0644)
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package test

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

var (
        // command line options
        fileIntegration string
        maxErrors       int
        summary         string

        // test-integration command
        IntegrationCmd = &amp;cobra.Command{
                Use:   "integration",
                Short: "Run an integration test on the cluster",
                RunE:  runTestIntegrationE,
        }
)

// add command specific options
func init() <span class="cov8" title="1">{
        IntegrationCmd.Flags().StringVarP(&amp;fileIntegration, "file", "f", "", "Test file to use")
        IntegrationCmd.Flags().IntVarP(&amp;maxErrors, "max-errors", "", 10, "Max validation errors before terminating test")
        IntegrationCmd.Flags().StringVarP(&amp;summary, "summary", "", "None", "Test summary display &lt;None|Tsv|Xml&gt;")
}</span>

// run the test-integration command
func runTestIntegrationE(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfmt.Info("Running integration test")

        if sleep &lt; 0 </span><span class="cov0" title="0">{
                sleep = 0
        }</span>

        // get shared options
        <span class="cov0" title="0">params := getTestFlagValues()

        if maxErrors &gt; 0 </span><span class="cov0" title="0">{
                params += fmt.Sprintf(" --max-errors %d", maxErrors)
        }</span>

        <span class="cov0" title="0">if summary != "" </span><span class="cov0" title="0">{
                params += " --summary " + summary
        }</span>

        <span class="cov0" title="0">if fileIntegration == "" </span><span class="cov0" title="0">{
                if boa.GetBinName() == "kivm" </span><span class="cov0" title="0">{
                        fileIntegration = "imdb-baseline.json heartbeat-baseline.json "
                }</span> else<span class="cov0" title="0"> {
                        fileIntegration = "imdb-baseline.json "
                }</span>
        }

        // add test-integration specific options to command line
        <span class="cov0" title="0">if fileIntegration != "" </span><span class="cov0" title="0">{
                params += " --files " + fileIntegration
        }</span>

        // get the webv container
        <span class="cov0" title="0">webv := os.Getenv("AKDC_WEBV")

        if webv == "" </span><span class="cov0" title="0">{
                webv = "ghcr.io/cse-labs/webv-red:latest"
        }</span>

        // build the path to the script
        <span class="cov0" title="0">path := "docker run --net host --rm " + webv + " --server "

        if boa.GetBinName() == "kivm" </span><span class="cov0" title="0">{
                path += "http://$AKDC_FQDN "
        }</span> else<span class="cov0" title="0"> {
                path += "http://localhost:30080 "
        }</span>

        <span class="cov0" title="0">path += " " + params

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                path += " " + strings.Join(args, " ")
        }</span>

        // execute the file with "bash -c" if it exists
        <span class="cov0" title="0">return boa.ShellExecE(path)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package test

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

var (
        // command line options
        fileLoad   string
        delayStart int
        duration   int
        random     bool

        // test-load command
        LoadCmd = &amp;cobra.Command{
                Use:   "load",
                Short: "Run a load test on the cluster",
                RunE:  runTestLoadE,
        }
)

// add command specific options
func init() <span class="cov8" title="1">{
        LoadCmd.Flags().StringVarP(&amp;fileLoad, "file", "f", "benchmark.json", "Test file to use")
        LoadCmd.Flags().IntVarP(&amp;delayStart, "delay-start", "", 0, "Delay test start (seconds)")
        LoadCmd.Flags().IntVarP(&amp;duration, "duration", "", 30, "Test duration (seconds)")
        LoadCmd.Flags().BoolVarP(&amp;random, "random", "", false, "Randomize tests")
}</span>

// run the test-load command
func runTestLoadE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfmt.Info("Running load test")

        if sleep &lt; 1 </span><span class="cov0" title="0">{
                sleep = 100
        }</span>

        // get shared options
        <span class="cov8" title="1">params := getTestFlagValues()

        // add test-load specific options to command line
        params += " --run-loop "

        if delayStart &gt; 0 </span><span class="cov8" title="1">{
                params += fmt.Sprintf(" --delay-start %d", delayStart)
        }</span>

        <span class="cov8" title="1">if duration &gt; 0 </span><span class="cov8" title="1">{
                params += fmt.Sprintf(" --duration %d", duration)
        }</span>

        <span class="cov8" title="1">if random </span><span class="cov8" title="1">{
                params += " --random"
        }</span>

        // keep this arg last to override for innerloop test run
        <span class="cov8" title="1">if fileLoad != "" </span><span class="cov8" title="1">{
                params += " --files " + fileLoad
        }</span>

        // get the webv container
        <span class="cov8" title="1">webv := os.Getenv("AKDC_WEBV")

        if webv == "" </span><span class="cov8" title="1">{
                webv = "ghcr.io/cse-labs/webv-red:latest"
        }</span>

        // build the path to the script
        <span class="cov8" title="1">path := "docker run --net host --rm " + webv + " --server "

        if boa.GetBinName() == "kivm" </span><span class="cov0" title="0">{
                path += "http://$AKDC_FQDN "
        }</span> else<span class="cov8" title="1"> {
                path += "http://localhost:30080 "
        }</span>

        <span class="cov8" title="1">path += " " + params

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                path += " " + strings.Join(args, " ")
        }</span>

        // execute the file with "bash -c" if it exists
        <span class="cov8" title="1">return boa.ShellExecE(path)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package test

import (
        "fmt"
        "github.com/spf13/cobra"
)

var (
        // shared options
        dryRun    bool
        logFormat string
        region    string
        sleep     int
        tag       string
        verbose   bool
        zone      string

        // test command
        TestCmd = &amp;cobra.Command{
                Use:   "test",
                Short: "Run cluster tests",
        }
)

// initialize the test command
func init() <span class="cov8" title="1">{
        // add sub-commands
        TestCmd.AddCommand(IntegrationCmd)
        TestCmd.AddCommand(LoadCmd)

        // add common options
        TestCmd.PersistentFlags().BoolVarP(&amp;dryRun, "dry-run", "d", false, "Validate configuration without running")
        TestCmd.PersistentFlags().StringVarP(&amp;logFormat, "log-format", "", "", "Log format &lt;Json|JsonCamel|None|Tsv|TsvMin&gt;")
        TestCmd.PersistentFlags().StringVarP(&amp;region, "region", "", "", "Region deployed to (user defined)")
        TestCmd.PersistentFlags().IntVarP(&amp;sleep, "sleep", "l", 0, "Sleep (ms) between each request")
        TestCmd.PersistentFlags().StringVarP(&amp;tag, "tag", "", "", "Tag for log (user defined)")
        TestCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Show verbose results")
        TestCmd.PersistentFlags().StringVarP(&amp;zone, "zone", "", "", "Zone deployed to (user defined)")
}</span>

// add the shared flags to the command line
func getTestFlagValues() string <span class="cov8" title="1">{
        cmd := ""

        if verbose </span><span class="cov8" title="1">{
                cmd += " --verbose"
        }</span>
        <span class="cov8" title="1">if sleep &gt; 0 </span><span class="cov8" title="1">{
                cmd += fmt.Sprintf(" --sleep %d", sleep)
        }</span>
        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                cmd += " --dry-run"
        }</span>
        <span class="cov8" title="1">if region != "" </span><span class="cov8" title="1">{
                cmd += " --region " + region
        }</span>
        <span class="cov8" title="1">if zone != "" </span><span class="cov8" title="1">{
                cmd += " --zone " + zone
        }</span>
        <span class="cov8" title="1">if tag != "" </span><span class="cov8" title="1">{
                cmd += " --tag " + tag
        }</span>
        <span class="cov8" title="1">if logFormat != "" </span><span class="cov8" title="1">{
                cmd += " --log-format " + logFormat
        }</span>

        <span class="cov8" title="1">return cmd</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package main

import "kic/cmd"

// execute the root command in cmd/root.go
func main() <span class="cov8" title="1">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
