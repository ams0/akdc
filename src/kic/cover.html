
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>boa: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kic/boa/boa.go (62.6%)</option>
				
				<option value="file1">kic/boa/boaExecCmd.go (0.0%)</option>
				
				<option value="file2">kic/boa/cfmt/cfmt.go (70.8%)</option>
				
				<option value="file3">kic/boa/io.go (56.0%)</option>
				
				<option value="file4">kic/boa/shell.go (87.5%)</option>
				
				<option value="file5">kic/cmd/fleet/create.go (30.1%)</option>
				
				<option value="file6">kic/cmd/fleet/delete.go (0.0%)</option>
				
				<option value="file7">kic/cmd/fleet/exec.go (83.3%)</option>
				
				<option value="file8">kic/cmd/fleet/fleet.go (100.0%)</option>
				
				<option value="file9">kic/cmd/fleet/list.go (86.7%)</option>
				
				<option value="file10">kic/cmd/fleet/ssh.go (0.0%)</option>
				
				<option value="file11">kic/cmd/root.go (59.3%)</option>
				
				<option value="file12">kic/cmd/targets/targets-add.go (88.9%)</option>
				
				<option value="file13">kic/cmd/targets/targets-clear.go (87.5%)</option>
				
				<option value="file14">kic/cmd/targets/targets-deploy.go (0.0%)</option>
				
				<option value="file15">kic/cmd/targets/targets-list.go (75.0%)</option>
				
				<option value="file16">kic/cmd/targets/targets-remove.go (76.5%)</option>
				
				<option value="file17">kic/cmd/targets/targets.go (75.8%)</option>
				
				<option value="file18">kic/cmd/test/test-integration.go (81.2%)</option>
				
				<option value="file19">kic/cmd/test/test-load.go (90.5%)</option>
				
				<option value="file20">kic/cmd/test/test.go (100.0%)</option>
				
				<option value="file21">kic/main.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "fmt"
        "io/ioutil"
        "kic/boa/cfmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
)

var boaPath string
var boaCommandPath string

var boaRootCmd *cobra.Command

// load commands from *.boa
// commands are in the .binName directory
//    that is a subdirectory of where the bin file is located
// example: /bin/.kic
func LoadCommands(appRootCmd *cobra.Command) <span class="cov8" title="1">{
        // set boaRootCmd to the app root command
        boaRootCmd = appRootCmd

        boaPath = GetBoaPath()
        boaCommandPath = GetBoaCommandPath()

        // load boaPath/*.boa
        files, err := ioutil.ReadDir(boaPath)
        if err == nil </span><span class="cov8" title="1">{
                for _, f := range files </span><span class="cov8" title="1">{
                        if !f.IsDir() &amp;&amp; strings.HasSuffix(strings.ToLower(f.Name()), ".boa") </span><span class="cov8" title="1">{
                                loadCommand(f.Name())
                        }</span>
                }
        }
}

// get a command by Use (Name)
func GetCommandByUse(cmd *cobra.Command, use string) *cobra.Command <span class="cov8" title="1">{
        if cmd != nil &amp;&amp; len(cmd.Commands()) &gt; 0 </span><span class="cov8" title="1">{
                for _, c := range cmd.Commands() </span><span class="cov8" title="1">{
                        if c.Use == use </span><span class="cov8" title="1">{
                                return c
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// reset cmdRoot to new__root command if set
// otherwise remove any hidden root commands
func SetNewRoot() *cobra.Command <span class="cov8" title="1">{
        var cmd *cobra.Command

        // create a new root command
        cmd = &amp;cobra.Command{Use: boaRootCmd.Use, Short: boaRootCmd.Short, Long: boaRootCmd.Long}

        // check for new__root
        nr := GetCommandByUse(boaRootCmd, "new__root")

        if nr == nil </span><span class="cov8" title="1">{
                // add all non-hidden commands to the new root
                for _, c := range boaRootCmd.Commands() </span><span class="cov8" title="1">{
                        if !c.Hidden </span><span class="cov8" title="1">{
                                cmd.AddCommand(c)
                        }</span>
                        <span class="cov8" title="1">boaRootCmd = cmd</span>
                }
        } else<span class="cov0" title="0"> {
                // get the new root
                cmd = GetCommandByUse(boaRootCmd, nr.Short)

                if cmd == nil </span><span class="cov0" title="0">{
                        // new__root not found
                        cfmt.ErrorE("New root command not found", nr.Short)
                        os.Exit(1)
                }</span>

                // create the new boaRootCmd
                // we have to do this as the parent is set to the existing boaRootCmd
                <span class="cov0" title="0">nr = &amp;cobra.Command{Use: boaRootCmd.Use, Short: cmd.Short, Long: cmd.Long}

                for _, c := range cmd.Commands() </span><span class="cov0" title="0">{
                        // add all commands that aren't hidden
                        if !c.Hidden </span><span class="cov0" title="0">{
                                nr.AddCommand(c)
                        }</span>
                }
                <span class="cov0" title="0">boaRootCmd = nr</span>
        }

        <span class="cov8" title="1">return boaRootCmd</span>
}

// return the stop word for file reads
func getStopWord(line string) string <span class="cov8" title="1">{

        chk := strings.ToLower(line)

        if strings.HasPrefix(chk, "root") </span><span class="cov8" title="1">{
                return "root"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(chk, "command") </span><span class="cov8" title="1">{
                return "command"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(chk, "runcommand") </span><span class="cov8" title="1">{
                return "runCommand"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(chk, "fltcommand") </span><span class="cov8" title="1">{
                return "fltCommand"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(chk, "popcommand") </span><span class="cov0" title="0">{
                return "popCommand"
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// load command(s) from a file
func loadCommand(fileName string) <span class="cov8" title="1">{
        var boaCmd *cobra.Command

        // todo - convert to struct
        var modType string
        var name string
        var short string
        var long string
        var path string
        var parent string
        var hidden bool

        // read file into an array
        lines := ReadLinesFromFile(filepath.Join(boaPath, fileName))

        for i := 0; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := strings.TrimSpace(lines[i])
                line = strings.Replace(line, "\\n", "\n", -1)

                // ignore comments
                if !strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        chk := strings.ToLower(line)

                        // check for stop word
                        sw := getStopWord(chk)
                        if sw != "" </span><span class="cov8" title="1">{
                                if strings.HasPrefix(sw, "popCommand") </span><span class="cov0" title="0">{
                                        // popCommand resets the command to the parent or boaRootCmd
                                        addBoaCommand(fileName, boaCmd, modType, name, short, long, path, parent, hidden)
                                        if boaCmd != nil </span><span class="cov0" title="0">{
                                                boaCmd = boaCmd.Parent()
                                                if boaCmd == boaRootCmd </span><span class="cov0" title="0">{
                                                        boaCmd = nil
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> {
                                        // add the command and set the new type based on stopWord
                                        boaCmd = addBoaCommand(fileName, boaCmd, modType, name, short, long, path, parent, hidden)
                                }</span>

                                // reset params
                                <span class="cov8" title="1">modType = sw
                                name = ""
                                parent = ""
                                short = ""
                                long = ""
                                path = ""
                                hidden = false</span>
                        } else<span class="cov8" title="1"> if strings.HasPrefix(strings.ToLower(line), "name:") </span><span class="cov8" title="1">{
                                name = strings.TrimSpace(line[5:])
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(strings.ToLower(line), "parent:") </span><span class="cov0" title="0">{
                                parent = strings.TrimSpace(line[7:])
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(strings.ToLower(line), "short:") </span><span class="cov8" title="1">{
                                short = strings.TrimSpace(line[6:])
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(strings.ToLower(line), "long:") </span><span class="cov8" title="1">{
                                long = strings.TrimSpace(line[5:])
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(strings.ToLower(line), "path:") </span><span class="cov8" title="1">{
                                path = strings.TrimSpace(line[5:])
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(strings.ToLower(line), "hidden:") </span><span class="cov0" title="0">{
                                hidden = strings.ToLower(strings.TrimSpace(line[7:])) == "true"
                        }</span> else<span class="cov8" title="1"> {
                                if line != "" </span><span class="cov0" title="0">{
                                        cfmt.ErrorE("unrecognized line: " + line)
                                }</span>
                        }
                }
        }

        // handle last command at EOF
        <span class="cov8" title="1">if modType != "" </span><span class="cov8" title="1">{
                addBoaCommand(fileName, boaCmd, modType, name, short, long, path, parent, hidden)
        }</span>
}

// add a command or command to cobra
func addBoaCommand(fileName string, modCmd *cobra.Command, modType string, name string, short string, long string, path string, parent string, hidden bool) *cobra.Command <span class="cov8" title="1">{
        // ignore if modType not set
        if modType == "" || modType == "popCommand" </span><span class="cov8" title="1">{
                return modCmd
        }</span>

        // handle different command and command types
        <span class="cov8" title="1">if modType == "root" </span><span class="cov8" title="1">{
                return setRootValues(name, short, long)
        }</span> else<span class="cov8" title="1"> if modType == "command" </span><span class="cov8" title="1">{
                return addParentCommand(modCmd, name, short, long, parent, hidden)
        }</span> else<span class="cov8" title="1"> if modType == "runCommand" || modType == "fltCommand" </span><span class="cov8" title="1">{
                return addCommand(modCmd, modType, name, short, long, path, hidden)
        }</span>

        // bad input file
        <span class="cov0" title="0">cfmt.ErrorE("unrecognized Command in file:", fileName, modType, name, short, long, path)
        os.Exit(1)
        return nil</span>
}

// add a command to the command tree
func addParentCommand(modCmd *cobra.Command, name string, short string, long string, parent string, hidden bool) *cobra.Command <span class="cov8" title="1">{
        if !hidden </span><span class="cov8" title="1">{
                // name and short are required
                if err := checkNameAndShort(name, short); err != nil </span><span class="cov0" title="0">{
                        return modCmd
                }</span>
        } else<span class="cov0" title="0"> {
                short = "hidden"
                long = ""
        }</span>

        // create the new command
        <span class="cov8" title="1">boaCmd := createCommand(name, short, long)
        boaCmd.Hidden = hidden

        if parent != "" </span><span class="cov0" title="0">{
                // set the parent if specified
                if strings.ToLower(parent) == "boaRootCmd" </span><span class="cov0" title="0">{
                        modCmd = nil
                }</span> else<span class="cov0" title="0"> {
                        modCmd = GetCommandByUse(boaRootCmd, parent)
                        if modCmd == nil </span><span class="cov0" title="0">{
                                cfmt.ErrorE("Parent command not found", parent)
                                os.Exit(1)
                        }</span>
                }
        }

        <span class="cov8" title="1">if modCmd != nil </span><span class="cov8" title="1">{
                // check for dupes
                if GetCommandByUse(modCmd, name) != nil </span><span class="cov0" title="0">{
                        if hidden </span><span class="cov0" title="0">{
                                GetCommandByUse(modCmd, name).Hidden = true
                        }</span> else<span class="cov0" title="0"> {
                                cfmt.ErrorE("Command already exists", modCmd.Use, name)
                                os.Exit(1)
                        }</span>
                } else<span class="cov8" title="1"> {
                        modCmd.AddCommand(boaCmd)
                }</span>
        } else<span class="cov8" title="1"> {
                // check for dupes
                if GetCommandByUse(boaRootCmd, name) != nil </span><span class="cov0" title="0">{
                        if hidden </span><span class="cov0" title="0">{
                                GetCommandByUse(boaRootCmd, name).Hidden = true
                        }</span> else<span class="cov0" title="0"> {
                                cfmt.ErrorE("Command already exists", boaRootCmd.Use, name)
                                os.Exit(1)
                        }</span>
                } else<span class="cov8" title="1"> {
                        boaRootCmd.AddCommand(boaCmd)
                }</span>
        }

        // set the new command to the parent
        <span class="cov8" title="1">return boaCmd</span>
}

// add a command to a command in the command tree
func addCommand(modCmd *cobra.Command, modType string, name string, short string, long string, path string, hidden bool) *cobra.Command <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                cfmt.ErrorE("path is required", name, short, long, path)
                os.Exit(1)
        }</span>

        // read the values from the command metadata if necessary
        <span class="cov8" title="1">name = readFromCommandFile(path, "name", name)
        short = readFromCommandFile(path, "short", short)
        long = readFromCommandFile(path, "long", long)

        if !hidden </span><span class="cov8" title="1">{
                // name and short are required
                if err := checkNameAndShort(name, short); err != nil </span><span class="cov0" title="0">{
                        return modCmd
                }</span>
        } else<span class="cov0" title="0"> {
                short = "hidden"
                long = ""
        }</span>

        // use boaRootCmd if modCmd is nil
        <span class="cov8" title="1">aCmd := modCmd
        if aCmd == nil </span><span class="cov8" title="1">{
                aCmd = boaRootCmd
        }</span>

        // check for dupes
        <span class="cov8" title="1">if GetCommandByUse(aCmd, name) != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("Command already exists", aCmd.Use, name)
                os.Exit(1)
        }</span>

        // add the command
        <span class="cov8" title="1">var cmd *cobra.Command

        if modType == "runCommand" </span><span class="cov8" title="1">{
                cmd = addRunCommand(name, short, long, path)
        }</span> else<span class="cov8" title="1"> if modType == "fltCommand" </span><span class="cov8" title="1">{
                cmd = addFltCommand(name, short, long, path)
        }</span>

        <span class="cov8" title="1">cmd.Hidden = hidden
        aCmd.AddCommand(cmd)

        // parent doesn't change
        return modCmd</span>
}

// set the root command values
func setRootValues(name string, short string, long string) *cobra.Command <span class="cov8" title="1">{
        // name and short are required
        if err := checkNameAndShort(name, short); err == nil </span><span class="cov8" title="1">{
                boaRootCmd.Use = name
                boaRootCmd.Short = short

                // this will default to short if not set
                if long != "" </span><span class="cov8" title="1">{
                        boaRootCmd.Long = long
                }</span>
        }

        // reset parent
        <span class="cov8" title="1">return nil</span>
}

// this will exit if name or short are invalid
func checkNameAndShort(name string, short string) error <span class="cov8" title="1">{
        // name and short are required
        if name == "" || short == "" </span><span class="cov0" title="0">{
                if name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("name: is required")
                }</span>
                <span class="cov0" title="0">if short == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("short: is required")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// read the metadata from the command
func readFromCommandFile(path string, key string, value string) string <span class="cov8" title="1">{
        // don't read if already set
        if value != "" </span><span class="cov8" title="1">{
                return value
        }</span>

        <span class="cov8" title="1">key = strings.TrimSpace(strings.ToLower(key)) + ":"
        p := filepath.Join(boaCommandPath, path)

        // read the file into an array
        txt := ReadTextFile(p)
        lines := strings.Split(txt, "\n")

        for i := 0; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := strings.TrimSpace(lines[i])

                if strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        // check all comments for metadata
                        line = strings.TrimSpace(strings.TrimLeft(line, "#"))

                        if strings.HasPrefix(strings.ToLower(line), key) </span><span class="cov8" title="1">{
                                // extract the metadata
                                line = strings.TrimSpace(line[len(key):])
                                return line
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// add a command that has sub-commands
func createCommand(use string, short string, long string) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,
        }

        return cmd
}</span>

// create a command that runs the bash command
func addRunCommand(use string, short string, long string, command string) *cobra.Command <span class="cov8" title="1">{
        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                ShellExecArgsE(filepath.Join(boaCommandPath, command), args)
                        }</span> else<span class="cov0" title="0"> {
                                ShellExecE(filepath.Join(boaCommandPath, command))
                        }</span>
                },
        }

        <span class="cov8" title="1">return runCmd</span>
}

var grep string

// create a command that runs the bash command across the fleet
func addFltCommand(use string, short string, long string, command string) *cobra.Command <span class="cov8" title="1">{
        fltCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        script := filepath.Join(".", "cli", "vm", "scripts", command)

                        // add the paramaters
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                script += " " + strings.Join(args, " ")
                        }</span>

                        <span class="cov0" title="0">return ExecClusters(script, grep)</span>
                },
        }

        <span class="cov8" title="1">fltCmd.PersistentFlags().StringVarP(&amp;grep, "grep", "g", "", "grep conditional to filter by host")

        return fltCmd</span>
}

// create a command that runs the bash command
func AddRunCommand(use string, short string, long string, command string) *cobra.Command <span class="cov0" title="0">{
        cmdPath := GetBoaCommandPath()

        runCmd := &amp;cobra.Command{
                Use:   use,
                Short: short,
                Long:  long,

                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                ShellExecArgsE(cmdPath+command, args)
                        }</span> else<span class="cov0" title="0"> {
                                ShellExecE(filepath.Join(cmdPath, command))
                        }</span>
                },
        }

        <span class="cov0" title="0">return runCmd</span>
}

// run a command on all clusters
func ExecClusters(cmd string, grep string) error <span class="cov0" title="0">{
        hostIPs, err := ReadHostIPs(grep)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ch := make(chan string)

        for _, hostIP := range hostIPs </span><span class="cov0" title="0">{
                cols := strings.Split(hostIP, "\t")

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        go ExecCluster(cols[0], cols[1], cmd, ch)
                }</span>
        }

        // todo - add timeout
        <span class="cov0" title="0">for i := 0; i &lt; len(hostIPs); i++ </span><span class="cov0" title="0">{
                &lt;-ch
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// run a command on one cluster via ssh
func ExecCluster(host string, ip string, cmd string, ch chan string) <span class="cov0" title="0">{
        cmd = fmt.Sprintf("ssh -p 2222 -o \"StrictHostKeyChecking=no\" -o ConnectTimeout=5 akdc@%s %s", ip, cmd)

        ShellExecE(cmd)

        ch &lt;- host
}</span>

// execute a command in bin/.kic/commands
func ExecCommandE(cmd string) error <span class="cov0" title="0">{
        path := GetBoaCommandPath() + cmd

        // execute the file with "bash -c" if it exists
        _, err := os.Stat(path)

        if err == nil </span><span class="cov0" title="0">{
                cfmt.Info("Running command: " + cmd)

                err = ShellExecE(fmt.Sprintf("%s %s", path, os.Args))
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "bytes"
        "io"
        "kic/boa/cfmt"
        "os"
        "strings"
        "testing"

        "github.com/spf13/cobra"
)

func ExecCmdNoErrorE(t *testing.T, c *cobra.Command, args ...string) error <span class="cov0" title="0">{
        t.Helper()

        arg := ""
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                arg = args[0]
        }</span>

        <span class="cov0" title="0">cfmt.Info(t.Name(), c.Name(), arg)

        c.SetArgs(args)
        err := c.Execute()

        if err != nil </span><span class="cov0" title="0">{
                t.Error("Unexpected error:", err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func ExecCmdWithErrorE(t *testing.T, errMatch string, c *cobra.Command, args ...string) error <span class="cov0" title="0">{
        t.Helper()

        c.SetArgs(args)
        err := c.Execute()

        if err == nil </span><span class="cov0" title="0">{
                t.Error("Expected error", errMatch)
        }</span> else<span class="cov0" title="0"> {
                if !strings.Contains(err.Error(), errMatch) </span><span class="cov0" title="0">{
                        t.Errorf("Expected error %s; got error %s", errMatch, err)
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

// execute command and return result and error
// warning: this is not thread safe
func ExecCmdWithResultsE(t *testing.T, resultMatch string, errMatch string, c *cobra.Command, args ...string) (string, error) <span class="cov0" title="0">{
        t.Helper()

        var (
                old *os.File
                r   *os.File
                w   *os.File
                buf *bytes.Buffer
        )

        // redirect stdout so we can capture
        old = os.Stdout
        r, w, _ = os.Pipe()
        os.Stdout = w

        buf = new(bytes.Buffer)
        c.SetOut(buf)
        c.SetErr(buf)

        c.SetArgs(args)
        err := c.Execute()

        // reset stdout
        w.Close()
        os.Stdout = old
        io.Copy(buf, r)
        result := strings.TrimSpace(buf.String())

        if !strings.Contains(result, resultMatch) </span><span class="cov0" title="0">{
                t.Error("Result does not match:", resultMatch)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), errMatch) </span><span class="cov0" title="0">{
                        t.Errorf("Expected error %s; got error %s", errMatch, err)
                }</span>
        } else<span class="cov0" title="0"> if errMatch != "" </span><span class="cov0" title="0">{
                t.Errorf("Expected error %s, got nil", errMatch)
        }</span>

        <span class="cov0" title="0">return result, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cfmt

import (
        "fmt"
        "os"
        "runtime"
)

var (
        Reset  string
        Blue   string
        Cyan   string
        Gray   string
        Green  string
        Purple string
        Red    string
        White  string
        Yellow string
)

// print an info message in cyan
func Info(msg ...interface{}) <span class="cov8" title="1">{
        fmt.Print(Cyan)
        fmt.Print(msg...)
        fmt.Println(Reset)
}</span>

// print the error in red and return params as error
func ErrorE(msg ...interface{}) error <span class="cov8" title="1">{
        fmt.Print(Red)
        fmt.Print(msg...)
        fmt.Println(Reset)
        return fmt.Errorf("%v", fmt.Sprint(msg...))
}</span>

func init() <span class="cov8" title="1">{
        // Windows doesn't support ANSI colors
        if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                Reset = "\033[0m"
                Blue = "\033[34m"
                Cyan = "\033[36m"
                Gray = "\033[37m"
                Green = "\033[32m"
                Purple = "\033[35m"
                Red = "\033[31m"
                White = "\033[97m"
                Yellow = "\033[33m"
        }</span>
}

// append text to path
func FAppendToFile(path string, text string) error <span class="cov0" title="0">{
        f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

        if err != nil </span><span class="cov0" title="0">{
                return ErrorE(err)
        }</span>

        <span class="cov0" title="0">defer f.Close()

        if _, err := f.WriteString(text); err != nil </span><span class="cov0" title="0">{
                return ErrorE(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "fmt"
        "kic/boa/cfmt"
        "log"
        "os"
        "path"
        "path/filepath"
        "strings"
)

// read key from ~/.kic
func ReadConfigValue(key string) string <span class="cov8" title="1">{
        key = strings.TrimSpace(key)

        if !strings.HasSuffix(key, ":") </span><span class="cov8" title="1">{
                key += ":"
        }</span>

        <span class="cov8" title="1">config := os.Getenv("HOME") + "/.kic"

        if _, err := os.Stat(config); err == nil </span><span class="cov8" title="1">{
                lines := ReadLinesFromFile(config)

                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        if strings.HasPrefix(line, key) </span><span class="cov8" title="1">{
                                line = strings.TrimSpace(strings.Replace(line, key, "", 1))
                                return line
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// read the ips file
func ReadHostIPs(grep string) ([]string, error) <span class="cov8" title="1">{
        command := ""

        if _, err := os.Stat("./ips"); err != nil </span><span class="cov8" title="1">{
                file := ReadConfigValue("defaultIPs:")
                if file != "" </span><span class="cov8" title="1">{
                        command = "cat " + file + " | sort"
                }</span>
        } else<span class="cov0" title="0"> {
                command = "cat ips | sort"
        }</span>

        <span class="cov8" title="1">if command == "" </span><span class="cov0" title="0">{
                cfmt.ErrorE("fleet file not found")
        }</span>

        <span class="cov8" title="1">if grep != "" </span><span class="cov8" title="1">{
                err := CheckForBadChars(grep, "grep")
                if err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE(err)
                        return nil, err
                }</span>

                <span class="cov8" title="1">command += " | grep " + grep</span>
        }

        <span class="cov8" title="1">res, err := ShellExecOut(command, false)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">lines := strings.Split(res, "\n")

        var ips []string = nil

        for _, line := range lines </span><span class="cov0" title="0">{
                ip := strings.Split(line, "\t")

                if len(ip) &gt; 1 </span><span class="cov0" title="0">{
                        ips = append(ips, line)
                }</span>
        }

        <span class="cov0" title="0">return ips, nil</span>
}

// read a completion file
func ReadCompletionFile(fileName string) ([]string, error) <span class="cov0" title="0">{
        path := path.Join(GetBoaPath(), fileName)

        if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ReadLinesFromFile(path), nil</span>
}

// get the path to the executable's directory
func GetBinDir() string <span class="cov8" title="1">{
        // read from env var
        ex := os.Getenv("KIC_PATH")
        if ex != "" </span><span class="cov8" title="1">{
                return ex
        }</span>

        <span class="cov0" title="0">ex, _ = os.Getwd()

        // return the working directory on tests
        if strings.HasPrefix(ex, "/tmp/") || strings.HasPrefix(GetBinName(), "__debug") </span><span class="cov0" title="0">{
                return ex
        }</span>

        <span class="cov0" title="0">ex, err := os.Executable()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // get the parent of bin
        <span class="cov0" title="0">return filepath.Dir(ex)</span>
}

// get the file name from the executing directory
func GetBinName() string <span class="cov8" title="1">{
        // read from env var
        ex := os.Getenv("KIC_NAME")
        if ex != "" </span><span class="cov8" title="1">{
                return ex
        }</span>

        <span class="cov0" title="0">ex, err := os.Executable()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // get the parent of bin
        <span class="cov0" title="0">return filepath.Base(ex)</span>
}

// get the path to the commands (i.e. /bin/kic/.kic)
func GetBoaPath() string <span class="cov8" title="1">{
        boaPath := GetBinDir()
        app := GetBinName()
        appConfig := "." + app

        // check current directory first
        if local, err := os.Getwd(); err == nil </span><span class="cov8" title="1">{
                local = filepath.Join(local, appConfig)

                if _, err := os.Stat(local); err == nil </span><span class="cov0" title="0">{
                        return local
                }</span>
        }

        // running in debugger
        <span class="cov8" title="1">if strings.HasPrefix(app, "__debug") </span><span class="cov0" title="0">{
                // assume package name == source directory
                app = filepath.Base(boaPath)
                appConfig = "." + app

                if _, err := os.Stat(appConfig); err != nil </span><span class="cov0" title="0">{
                        // walk the path to find the first bin dir
                        tpath := filepath.Dir(boaPath)
                        _, err := os.Stat(filepath.Join(tpath, "bin", appConfig))

                        for err != nil &amp;&amp; tpath != "/" </span><span class="cov0" title="0">{
                                tpath = filepath.Dir(tpath)
                                _, err = os.Stat(filepath.Join(tpath, "bin", appConfig))
                        }</span>

                        <span class="cov0" title="0">if tpath != "/" </span><span class="cov0" title="0">{
                                boaPath = filepath.Join(tpath, "bin")
                        }</span>
                }
        }

        // complete the path
        <span class="cov8" title="1">return filepath.Join(boaPath, appConfig)</span>
}

// get the path to the boa commands
func GetBoaCommandPath() string <span class="cov8" title="1">{
        return filepath.Join(GetBoaPath(), "commands")
}</span>

// get the path to the repo base
func GetRepoBase() string <span class="cov8" title="1">{
        base := os.Getenv("REPO_BASE")

        if base == "" </span><span class="cov0" title="0">{
                ex, err := os.Executable()

                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">base = filepath.Dir(ex)
                base = filepath.Dir(base)

                if strings.HasSuffix(base, "src") </span><span class="cov0" title="0">{
                        base = filepath.Dir(base)
                }</span>
        }

        <span class="cov8" title="1">return base</span>
}

// read a text file from the boa directory
// i.e. /bin/kic/.kic
func ReadTextFileFromBoaDir(name string) string <span class="cov8" title="1">{
        path := filepath.Join(GetBoaPath(), name)
        return ReadTextFile(path)
}</span>

// read a file and return the text
func ReadTextFile(path string) string <span class="cov8" title="1">{
        content, err := os.ReadFile(path)

        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return string(content)</span>
}

// read lines from a text file
func ReadLinesFromFile(path string) []string <span class="cov8" title="1">{
        return strings.Split(ReadTextFile(path), "\n")
}</span>

// check for dangerous characters sent to bash
func CheckForBadChars(source string, param string) error <span class="cov8" title="1">{

        if source != "" </span><span class="cov8" title="1">{
                badChars := "|&amp;;&lt;&gt;"

                for _, ch := range badChars </span><span class="cov8" title="1">{
                        if strings.Contains(source, string(ch)) </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid character in parameter %s", param)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package boa

import (
        "bytes"
        "os"
        "os/exec"
)

// execute a bash command with args
func ShellExecArgsE(cmd string, args []string) error <span class="cov8" title="1">{
        command := cmd
        for _, arg := range args </span><span class="cov0" title="0">{
                command += " " + arg
        }</span>
        <span class="cov8" title="1">return ShellExecE(command)</span>
}

// execute a bash command and return stdout
func ShellExecOut(cmd string, showErrors bool) (string, error) <span class="cov8" title="1">{
        shell := exec.Command("bash", "-c", cmd)

        var out bytes.Buffer
        shell.Stdout = &amp;out

        // show errors
        if showErrors </span><span class="cov0" title="0">{
                shell.Stderr = os.Stderr
        }</span>

        <span class="cov8" title="1">err := shell.Run()

        return out.String(), err</span>
}

// execute a bash command
func ShellExecE(cmd string) error <span class="cov8" title="1">{
        shell := exec.Command("bash", "-c", cmd)

        shell.Stdin = os.Stdin
        shell.Stdout = os.Stdout
        shell.Stderr = os.Stderr

        return shell.Run()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
)

var (
        // variables for options
        cluster           string
        group             string
        location          string
        repo              string
        branch            string
        pem               string
        key               string
        quiet             bool
        ssl               string
        dnsRG             string
        gitops            bool
        gitopsOnly        bool
        dapr              bool
        arcEnabled        bool
        digitalOcean      bool
        dryRun            bool
        debug             bool
        cores             int
        verbose           bool
        sku               string
        managedIdentityID = os.Getenv("AKDC_MI")

        // kic fleet create command
        CreateCmd = &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new cluster",
                Args:  validateCreateCmd,
                RunE:  runCreateCmd,
        }
)

// add kic fleet create specific flags
func init() <span class="cov8" title="1">{
        CreateCmd.Flags().StringVarP(&amp;cluster, "cluster", "c", "", "Kubernetes cluster name (required)")
        CreateCmd.MarkFlagRequired("cluster")
        CreateCmd.Flags().StringVarP(&amp;group, "group", "g", "", "Azure resource group name")
        CreateCmd.Flags().StringVarP(&amp;location, "location", "l", "centralus", "Azure location")
        CreateCmd.Flags().StringVarP(&amp;repo, "repo", "r", "retaildevcrews/edge-gitops", "GitOps repo name")
        CreateCmd.Flags().StringVarP(&amp;branch, "branch", "b", "", "GitOps branch name")
        CreateCmd.Flags().StringVarP(&amp;ssl, "ssl", "s", "", "SSL domain name")
        CreateCmd.Flags().StringVarP(&amp;pem, "pem", "p", "~/.ssh/certs.pem", "Path to SSL .pem file")
        CreateCmd.Flags().StringVarP(&amp;key, "key", "k", "~/.ssh/certs.key", "Path to SSL .key file")
        CreateCmd.Flags().StringVarP(&amp;dnsRG, "dns-resource-group", "", "tld", "DNS Resource Group")
        CreateCmd.Flags().BoolVarP(&amp;dapr, "dapr", "", false, "Install Dapr and Radius")
        CreateCmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false, "Quiet mode")
        CreateCmd.Flags().BoolVarP(&amp;debug, "debug", "d", false, "Create VM in debug mode")
        CreateCmd.Flags().BoolVarP(&amp;arcEnabled, "arc", "a", false, "Connect kubernetes cluster to Azure via Azure ARC")
        CreateCmd.Flags().BoolVarP(&amp;digitalOcean, "do", "", false, "Generate setup script for Digital Ocean droplet")
        CreateCmd.Flags().BoolVarP(&amp;gitops, "gitops", "", false, "Generate GitOps targets in ./config")
        CreateCmd.Flags().BoolVarP(&amp;gitopsOnly, "gitops-only", "", false, "Only generate GitOps targets in ./config")
        CreateCmd.Flags().BoolVarP(&amp;dryRun, "dry-run", "", false, "Show values that would be used")
        CreateCmd.Flags().BoolVarP(&amp;verbose, "verbose", "", false, "Show verbose output")
        CreateCmd.Flags().IntVarP(&amp;cores, "cores", "", 4, "VM core count")
        CreateCmd.Flags().StringVarP(&amp;sku, "sku", "", "", "Azure VM SKU")

        CreateCmd.RegisterFlagCompletionFunc("cluster", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return getClusterComplete(), cobra.ShellCompDirectiveDefault
        }</span>)

        <span class="cov8" title="1">CreateCmd.RegisterFlagCompletionFunc("cores", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return []string{"02", "04", "08", "16", "32"}, cobra.ShellCompDirectiveDefault
        }</span>)
}

// get a list of valid clusters for shell completion
func getClusterComplete() []string <span class="cov0" title="0">{
        return []string{
                "central-tx-dallas-101",
                "central-tx-dallas-102",
                "central-tx-dallas-103",
                "central-tx-dallas-104",
                "central-tx-dallas-105",
                "east-ga-atl-101",
                "east-ga-atl-102",
                "east-ga-atl-103",
                "east-ga-atl-104",
                "east-ga-atl-105",
                "west-ca-la-101",
                "west-ca-la-102",
                "west-ca-la-103",
                "west-ca-la-104",
                "west-ca-la-105",
        }
}</span>

// validation function for CreateCmd
func validateCreateCmd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // validate ssl and domain
        hasError := validateSSL()

        // validate cluster name against reserved prefixes (if set)
        hasError = hasError &amp;&amp; validateClusterPrefix()

        // managed identity is required for Azure VMs
        hasError = hasError &amp;&amp; validateManagedIdentity()

        // validate cores
        hasError = hasError &amp;&amp; validateCores()

        if hasError </span><span class="cov0" title="0">{
                return fmt.Errorf("create command aborted")
        }</span>

        // default resource group is cluster name
        <span class="cov8" title="1">if group == "" </span><span class="cov8" title="1">{
                group = cluster
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validate --ssl
func validateSSL() bool <span class="cov8" title="1">{
        hasError := false

        if ssl != "" </span><span class="cov8" title="1">{
                if pem == "" </span><span class="cov0" title="0">{
                        cfmt.ErrorE("you must specify --pem to use --ssl")
                        hasError = true
                }</span>

                <span class="cov8" title="1">if key == "" </span><span class="cov0" title="0">{
                        cfmt.ErrorE("you must specify --key to use --ssl")
                        hasError = true
                }</span>

                <span class="cov8" title="1">if len(ssl) &lt; 3 </span><span class="cov0" title="0">{
                        cfmt.ErrorE("--ssl parameter is too short")
                        hasError = true
                }</span>

                <span class="cov8" title="1">if !strings.Contains(ssl, ".") </span><span class="cov0" title="0">{
                        cfmt.ErrorE("malformed --ssl parameter")
                        hasError = true
                }</span>
        }
        <span class="cov8" title="1">return hasError</span>
}

// validate --cores
func validateCores() bool <span class="cov0" title="0">{
        validCores := map[int]int{2: 2, 4: 4, 8: 8, 16: 16, 32: 32}
        _, ok := validCores[cores]

        if !ok </span><span class="cov0" title="0">{
                cfmt.ErrorE("invalid --cores")
                fmt.Println("  valid: 2, 4, 8, 16, 32")
        }</span>

        <span class="cov0" title="0">return ok</span>
}

// validate managed identity
func validateManagedIdentity() bool <span class="cov0" title="0">{
        if !digitalOcean &amp;&amp; managedIdentityID == "" </span><span class="cov0" title="0">{
                cfmt.ErrorE("managed identity is required")
                fmt.Println("  export AKDC_MI=yourManagedIdentity")
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// validate cluster prefix
func validateClusterPrefix() bool <span class="cov0" title="0">{
        cl := strings.ToLower(cluster)

        blocked := boa.ReadConfigValue("reservedClusterPrefixes:")

        lines := strings.Split(blocked, " ")

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.ToLower(strings.TrimSpace(line))

                if line != "" &amp;&amp; strings.HasPrefix(cl, line) </span><span class="cov0" title="0">{
                        cfmt.ErrorE("cluster name is invalid - reserved prefix")
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// validate logged in to Azure
func validateAzureLogin() error <span class="cov0" title="0">{
        _, err := boa.ShellExecOut("az account show --query tenantId -o tsv", false)
        return err
}</span>

// validate Azure region
func validateLocation(loc string) error <span class="cov0" title="0">{
        res, err := boa.ShellExecOut("az account list-locations --query '[].name' -o table |  grep -x -i "+location, false)

        if err != nil || res == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", "invalid Azure Region")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validate VM SKU
func validateVmSku(loc string, vmSku string) error <span class="cov0" title="0">{
        res, err := boa.ShellExecOut("az vm list-sizes -o table -l "+location+" | grep -w -i "+vmSku, false)

        if err != nil || res == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", "invalid VM SKU")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validate PWD is a git repo
func validateRepo() bool <span class="cov0" title="0">{
        // required for --gitops
        if gitops || gitopsOnly </span><span class="cov0" title="0">{
                res, err := boa.ShellExecOut("git branch --show-current", false)

                if err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("Not a git repo")
                        cfmt.Info("Please re-run from a git repo")
                        return false
                }</span>

                <span class="cov0" title="0">res = strings.TrimSpace(res)

                // set branch to current branch
                if branch == "" </span><span class="cov0" title="0">{
                        branch = res
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// run the command
func runCreateCmd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if !digitalOcean </span><span class="cov0" title="0">{
                // validate PWD is a git repo
                if !validateRepo() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // validate azure login
                <span class="cov0" title="0">if validateAzureLogin() != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("please run az login first")
                        return nil
                }</span>
                // validate location
                <span class="cov0" title="0">location = strings.ToLower(location)

                if err := validateLocation(location); err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("Invalid location")
                        cfmt.Info("Valid Locations")
                        boa.ShellExecE("az account list-locations --query '[].name' -o table | sort")
                        fmt.Println()
                        cfmt.ErrorE("Invalid location")
                        return nil
                }</span>

                // SKU was not specified - try defaults
                <span class="cov0" title="0">if sku == "" </span><span class="cov0" title="0">{
                        // check the D4as_V5 SKU
                        sku = "Standard_D" + strconv.Itoa(cores) + "as_v5"

                        err := validateVmSku(location, sku)

                        if err != nil </span><span class="cov0" title="0">{
                                // check the D4s_v5 SKU
                                sku = "Standard_D" + strconv.Itoa(cores) + "s_v5"
                        }</span>
                }

                // validate VM SKU
                <span class="cov0" title="0">if err := validateVmSku(location, sku); err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("Invalid SKU")
                        cfmt.Info("Valid SKUs for region: " + location)
                        boa.ShellExecE("az vm list-sizes -l " + location + " -o table | grep _v5 | grep Standard_D" + " |awk '{print $3}' | sort")
                        fmt.Println()
                        cfmt.ErrorE("Invalid SKU")
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                return doDryRun()
        }</span>

        // add the GitOps target
        <span class="cov8" title="1">if gitops || gitopsOnly </span><span class="cov0" title="0">{
                addTargetE(cluster)
                cfmt.Info("Created GitOps config: ", cluster)

                // exit
                if gitopsOnly </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // fail if the Azure VM exists
        <span class="cov8" title="1">if vmExists() </span><span class="cov0" title="0">{
                cfmt.ErrorE("Azure VM Exists: ", cluster)
                return nil
        }</span>

        // create the setup script from the template
        <span class="cov8" title="1">createVMSetupScript()

        if digitalOcean </span><span class="cov8" title="1">{
                // no more automation for Digital Ocean droplets
                cfmt.Info("Digital Ocean template created")
                return nil
        }</span>

        // create the azure resource group
        <span class="cov0" title="0">if err := createGroup(); err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("createGroup Failed: ", cluster)
                return nil
        }</span>

        // create the vm and get the IP
        <span class="cov0" title="0">ip := createVM(managedIdentityID)

        // remove the cluster template
        os.Remove("cluster-" + cluster + ".sh")

        // success
        if ip != "" </span><span class="cov0" title="0">{
                cfmt.Info("VM Configured: ", cluster)
        }</span> else<span class="cov0" title="0"> {
                cfmt.ErrorE("VM Creation Failed: ", cluster)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handle --dry-run
func doDryRun() error <span class="cov8" title="1">{
        fmt.Println("Cluster:             ", cluster)
        fmt.Println("Cores:               ", cores)
        fmt.Println("Group:               ", group)

        if !digitalOcean </span><span class="cov0" title="0">{
                fmt.Println("VM SKU:              ", sku)
        }</span>

        <span class="cov8" title="1">fmt.Println("Managed Identity:    ", strings.Contains(managedIdentityID, "/Microsoft.ManagedIdentity/"))
        fmt.Println("Location:            ", location)
        fmt.Println("Repo:                ", repo)
        fmt.Println("Branch:              ", branch)

        if len(ssl) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Println("SSL Domain:          ", ssl)
                fmt.Println("SSL pem:             ", pem)
                fmt.Println("SSL key:             ", key)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("SSL Domain:           none")
        }</span>

        <span class="cov8" title="1">fmt.Println("Enable Arc:          ", arcEnabled)
        fmt.Println("Enable Dapr:         ", dapr)
        fmt.Println("Enable Digital Ocean:", digitalOcean)
        fmt.Println("Enable GitOps:       ", gitops)

        if !digitalOcean </span><span class="cov0" title="0">{
                fmt.Println("Cluster Exists:      ", vmExists())
                fmt.Println("Group Exists:        ", groupExists())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// check to see if the Azure Resource Group exists
func groupExists() bool <span class="cov0" title="0">{
        ex, _ := boa.ShellExecOut("az group exists -g "+group, false)
        return strings.HasPrefix(ex, "true")
}</span>

// check to see if the VM exists in the RG
func vmExists() bool <span class="cov8" title="1">{
        command := fmt.Sprintf("az vm show -g %s --name %s --query 'name' -o tsv", group, cluster)
        res, _ := boa.ShellExecOut(command, false)
        return strings.EqualFold(cluster, strings.TrimSpace(res))
}</span>

// get the path to template file
func getTemplatePath() string <span class="cov8" title="1">{
        return boa.GetBoaPath() + "/fleet-vm.templ"
}</span>

// create Azure Resource Group
func createGroup() error <span class="cov0" title="0">{
        // don't create the group if it exists
        if groupExists() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfmt.Info("Creating Azure Resource Group")

        rgTags := "akdc=true server=" + cluster

        if ssl != "" </span><span class="cov0" title="0">{
                rgTags += " zone=" + ssl
        }</span>

        <span class="cov0" title="0">command := "az group create -l " + location + " -n " + group + " -o table --tags " + rgTags

        err := boa.ShellExecE(command)
        if err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE(err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// create vm setup script
func createVMSetupScript() <span class="cov8" title="1">{
        os.Remove("cluster-" + cluster + ".sh")

        // create the custom VM script
        content, err := os.ReadFile(getTemplatePath())

        if err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE(err)
                return
        }</span>

        // create the vm setup script from the template
        <span class="cov8" title="1">command := string(content)
        command = strings.Replace(command, "{{cluster}}", cluster, -1)
        command = strings.Replace(command, "{{dapr}}", strconv.FormatBool(dapr), -1)
        command = strings.Replace(command, "{{debug}}", strconv.FormatBool(debug), -1)
        command = strings.Replace(command, "{{fqdn}}", cluster+"."+ssl, -1)
        command = strings.Replace(command, "{{repo}}", repo, -1)
        command = strings.Replace(command, "{{branch}}", branch, -1)
        command = strings.Replace(command, "{{group}}", group, -1)
        command = strings.Replace(command, "{{arcEnabled}}", strconv.FormatBool(arcEnabled), -1)
        command = strings.Replace(command, "{{do}}", strconv.FormatBool(digitalOcean), -1)
        command = strings.Replace(command, "{{zone}}", ssl, -1)
        command = strings.Replace(command, "{{dnsRG}}", dnsRG, -1)
        os.WriteFile("cluster-"+cluster+".sh", []byte(command), 0644)</span>
}

// create Azure VM
func createVM(managedIdentityID string) string <span class="cov0" title="0">{
        cfmt.Info("Creating Azure VM: ", cluster)

        command := "az vm create \\\n"
        command += " -g " + group + " \\\n"
        command += " -l " + location + " \\\n"
        command += " -n " + cluster + " \\\n"
        command += " --admin-username akdc \\\n"
        command += " --assign-identity " + managedIdentityID + "\\\n"
        command += " --size " + sku + " \\\n"
        command += " --image Canonical:0001-com-ubuntu-server-focal:20_04-lts-gen2:latest \\\n"
        command += " --os-disk-size-gb 128 \\\n"
        command += " --storage-sku Premium_LRS \\\n"
        command += " --generate-ssh-keys \\\n"
        command += " --public-ip-sku Standard \\\n"
        command += " --custom-data cluster-" + cluster + ".sh \\\n"
        command += " --query publicIpAddress \\\n"
        command += " -o tsv"

        ip, err := boa.ShellExecOut(command, verbose)
        ip = strings.TrimSpace(ip)

        if err != nil || ip == "" </span><span class="cov0" title="0">{
                cfmt.FAppendToFile("failed.log", cluster+"\n")
                return ""
        }</span>

        <span class="cov0" title="0">cfmt.Info("VM Created: ", cluster)
        fmt.Println(cluster, ip)
        cfmt.FAppendToFile("ips", fmt.Sprintf("%s\t%s\n", cluster, ip))

        cfmt.Info("Deleting NSG: ", cluster)
        command = "az network nsg rule delete -g " + group + " --nsg-name " + cluster + "NSG -o table --name default-allow-ssh"
        boa.ShellExecOut(command, false)

        cfmt.Info("Creating SSH Rule: ", cluster)

        command = "az network nsg rule create \\\n"
        command += "-g " + group + " \\\n"
        command += "--nsg-name " + cluster + "NSG \\\n"
        command += "-n SSH-http \\\n"
        command += "--description \"SSH http https\" \\\n"
        command += "--destination-port-ranges 2222 80 443 \\\n"
        command += "--protocol tcp \\\n"
        command += "--access allow \\\n"
        command += "--priority 1202 -o table"
        boa.ShellExecOut(command, false)

        return ip</span>
}

// get GitOps template
func getConfigJson(cluster string) []byte <span class="cov0" title="0">{
        region := cluster
        zone := cluster
        district := cluster

        cols := strings.Split(cluster, "-")

        if len(cols) &gt; 0 </span><span class="cov0" title="0">{
                region = cols[0]

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        zone = strings.Join(cols[0:2], "-")
                }</span>

                <span class="cov0" title="0">if len(cols) &gt; 2 </span><span class="cov0" title="0">{
                        district = strings.Join(cols[0:3], "-")
                }</span>
        }

        <span class="cov0" title="0">json := boa.ReadTextFileFromBoaDir("gitops-config.templ")

        if json == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // replace template values
        <span class="cov0" title="0">json = strings.Replace(json, "{{cluster}}", cluster, -1)
        json = strings.Replace(json, "{{region}}", region, -1)
        json = strings.Replace(json, "{{district}}", district, -1)
        json = strings.Replace(json, "{{zone}}", zone, -1)
        json = strings.Replace(json, "{{domain}}", ssl, -1)

        return []byte(json)</span>
}

// add a target to GitOps
func addTargetE(cluster string) error <span class="cov0" title="0">{
        // only run if --gitops specified
        if !(gitops || gitopsOnly) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // read the config.json file
        <span class="cov0" title="0">json := getConfigJson(cluster)

        // make sure the json is valid
        if json == nil || len(json) &lt; 3 || strings.Contains(string(json), "{{") </span><span class="cov0" title="0">{
                return cfmt.ErrorE("unable to read gitops-config.templ")
        }</span>

        <span class="cov0" title="0">return addTargetWorkerE(json)</span>
}

// add a target to GitOps
func addTargetWorkerE(json []byte) error <span class="cov0" title="0">{
        configDir := filepath.Join(".", "config")

        // add the targets
        if len(json) &gt; 0 &amp;&amp; !strings.Contains(string(json), "{{") </span><span class="cov0" title="0">{
                // make sure the dirs exist
                if _, err := os.Stat(configDir); err == nil </span><span class="cov0" title="0">{
                        // add cluster to the dirs
                        configDir = filepath.Join(configDir, cluster)

                        // create the directory
                        if err := boa.ShellExecE("mkdir -p " + configDir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // write config.json to each dir
                        <span class="cov0" title="0">configDir = filepath.Join(configDir, "config.json")

                        if _, err := os.Stat(configDir); err != nil </span><span class="cov0" title="0">{
                                if err := os.WriteFile(configDir, json, 0644); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov0" title="0">return updateGitOpsRepoE()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// update the GitOps repo with changes
func updateGitOpsRepoE() error <span class="cov0" title="0">{
        // if there were repo changes
        if res, _ := boa.ShellExecOut("git status -s", false); res != "" </span><span class="cov0" title="0">{
                // pull to avoid conflicts
                if _, err := boa.ShellExecOut("git pull", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update the repo
                <span class="cov0" title="0">if _, err := boa.ShellExecOut("git add .", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := boa.ShellExecOut("git commit -am 'flt create'", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // push the changes
                <span class="cov0" title="0">if _, err := boa.ShellExecOut("git push", false); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

// DeleteCmd deletes a cluster and DNS entry
var DeleteCmd = &amp;cobra.Command{
        Use:               "delete",
        Short:             "Delete an Azure Resource Group and associated Azure DNS record",
        Args:              cobra.ExactValidArgs(1),
        ValidArgsFunction: validArgsFleetDelete,
        RunE:              runFleetDeleteE,
}

// run kic fleet delete command
func runFleetDeleteE(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // check if resource group exists
        res, _ := boa.ShellExecOut(fmt.Sprintf("az group exists -n %s", args[0]), false)

        if strings.TrimSpace(res) == "true" </span><span class="cov0" title="0">{
                cfmt.Info("Deleting Resource Group")
                boa.ShellExecE(fmt.Sprintf("az group delete -n %s --yes --no-wait", args[0]))
        }</span>

        <span class="cov0" title="0">cfmt.Info("Deleting DNS Record")
        return (boa.ShellExecE(fmt.Sprintf("az network dns record-set a delete -g tld -z cseretail.com --yes -n %s", args[0])))</span>
}

// validate kic fleet delete args
func validArgsFleetDelete(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        // don't use the defaultIPs
        if _, err := os.Stat("ips"); err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // only one argument
        <span class="cov0" title="0">if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // suggest from the ips file
        <span class="cov0" title="0">if ips, err := boa.ReadHostIPs(""); err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span> else<span class="cov0" title="0"> {
                return ips, cobra.ShellCompDirectiveNoFileComp
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// execCmd runs a bash command on each server
var ExecCmd = &amp;cobra.Command{
        Use:   "exec",
        Short: "Execute a bash command on each server",
        Args:  cobra.MinimumNArgs(1),
        RunE:  runFleetExecE,
}

func init() <span class="cov8" title="1">{
        ExecCmd.Flags().StringVarP(&amp;grep, "grep", "g", "", "grep conditional to filter by host")
}</span>

// run kic fleet exec command
func runFleetExecE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        command := fmt.Sprintf("%s", args)

        // command will have []
        if len(command) &lt; 3 </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Usage: flt exec bashCommand")
        }</span>

        // remove []
        <span class="cov8" title="1">command = command[1 : len(command)-1]

        return (boa.ExecClusters(command, grep))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "github.com/spf13/cobra"
)

var (
        // option variables
        grep string

        // FleetCmd adds the kic fleet command tree
        FleetCmd = &amp;cobra.Command{
                Use:   "fleet",
                Short: "Commands for fleet of clusters",
        }
)

func init() <span class="cov8" title="1">{
        FleetCmd.AddCommand(CreateCmd)
        FleetCmd.AddCommand(DeleteCmd)
        FleetCmd.AddCommand(ExecCmd)
        FleetCmd.AddCommand(ListCmd)
        FleetCmd.AddCommand(SshCmd)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "strings"

        "github.com/spf13/cobra"
)

// ListCmd lists the clusters in the fleet
var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List the clusters in the fleet",
        RunE:  runFleetList,
}

func init() <span class="cov8" title="1">{
        ListCmd.Flags().StringVarP(&amp;grep, "grep", "g", "", "grep conditional to filter by host")
}</span>

// run the kic fleet list command
func runFleetList(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfmt.Info("Clusters in the fleet")
        fmt.Println()

        hostIPs, err := boa.ReadHostIPs("")

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, line := range hostIPs </span><span class="cov8" title="1">{
                cols := strings.Split(line, "\t")

                if len(cols) &gt; 1 </span><span class="cov8" title="1">{
                        fmt.Print(cols[0])
                        if len(cols[0]) &lt; 30 </span><span class="cov8" title="1">{
                                fmt.Print(strings.Repeat(" ", 30-len(cols[0])))
                        }</span>
                        <span class="cov8" title="1">fmt.Println(cols[1])</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(line)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package fleet

import (
        "kic/boa"
        "kic/boa/cfmt"
        "strings"

        "github.com/spf13/cobra"
)

var (
        // sshCmd opens an ssh terminal on a cluster
        SshCmd = &amp;cobra.Command{
                Use:   "ssh",
                Short: "Open an SSH shell to the cluster",
                Args:  cobra.ExactValidArgs(1),

                ValidArgsFunction: validArgsFleetSsh,

                RunE: runFleetSsh,
        }
)

// run kic fleet ssh command
func runFleetSsh(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // get the ip from the ips file
        hostIPs, err := boa.ReadHostIPs(args[0])

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ip := args[0]

        // try to lookup partial DNS name
        if len(hostIPs) &gt; 0 </span><span class="cov0" title="0">{
                ip = hostIPs[len(hostIPs)-1]
                cols := strings.Split(ip, "\t")

                if len(cols) &gt; 1 </span><span class="cov0" title="0">{
                        ip = strings.TrimSpace(cols[1])
                }</span>
        }

        <span class="cov0" title="0">if ip != "" </span><span class="cov0" title="0">{
                boa.ShellExecE("ssh -p 2222 -o \"StrictHostKeyChecking=no\" akdc@" + ip)
        }</span> else<span class="cov0" title="0"> {
                cfmt.ErrorE("unable to find host or IP")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validate kic fleet ssh arg
func validArgsFleetSsh(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        hostIPs, err := boa.ReadHostIPs("")

        if err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // only one arg
        <span class="cov0" title="0">if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // sugest from the ips or defaultIPs file
        <span class="cov0" title="0">return hostIPs, cobra.ShellCompDirectiveNoFileComp</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package cmd

import (
        "kic/boa"
        "kic/cmd/fleet"
        "kic/cmd/targets"
        "kic/cmd/test"
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command and adds commands, options, and flags
var (
        rootCmd = &amp;cobra.Command{
                Use:   "kic",
                Short: "Retail Edge CLI",
        }
)

// initialize the root command
// standard cobra function
// highly customized for boa support
func init() <span class="cov8" title="1">{
        // load the commands from the bin location ./.appName directory
        boa.LoadCommands(rootCmd)

        // add commands to kic
        if rootCmd.Name() == "kic" </span><span class="cov0" title="0">{
                addCommandIfNotExist("test", test.TestCmd)
                addCommandIfNotExist("targets", targets.TargetsCmd)
        }</span>

        // add fleet commands
        <span class="cov8" title="1">if rootCmd.Name() == "flt" </span><span class="cov8" title="1">{
                // add missing commands
                addCommandIfNotExist("create", fleet.CreateCmd)
                addCommandIfNotExist("delete", fleet.DeleteCmd)
                addCommandIfNotExist("exec", fleet.ExecCmd)
                addCommandIfNotExist("list", fleet.ListCmd)
                addCommandIfNotExist("ssh", fleet.SshCmd)
                addCommandIfNotExist("targets", targets.TargetsCmd)

                if check := boa.GetCommandByUse(rootCmd, "check"); check != nil </span><span class="cov8" title="1">{
                        if app := boa.GetCommandByUse(check, "app"); app != nil </span><span class="cov8" title="1">{
                                app.ValidArgsFunction = validArgsFleetCheckApp
                                app.Args = cobra.ExactValidArgs(1)
                        }</span>
                }
        }

        // this will set a new root if specified
        // this will also remove any hidden commands so they can't execute
        <span class="cov8" title="1">boa.SetNewRoot()</span>
}

// execute the root command
// standard cobra function
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// validate flt check app arg
// standard cobra function
func validArgsFleetCheckApp(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        apps, err := boa.ReadCompletionFile("flt-check-app-completion")

        if err != nil </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // only one arg
        <span class="cov0" title="0">if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>

        // sugest from the completion file
        <span class="cov0" title="0">return apps, cobra.ShellCompDirectiveNoFileComp</span>
}

// add the command to root if it doesn't exist
func addCommandIfNotExist(name string, cmd *cobra.Command) <span class="cov8" title="1">{
        if boa.GetCommandByUse(rootCmd, name) == nil </span><span class="cov8" title="1">{
                rootCmd.AddCommand(cmd)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// AddCmd adds a target to GitOps
var AddCmd = &amp;cobra.Command{
        Use:   "add",
        Short: "Add a GitOps target",

        Args: argsTargets,

        RunE: runTargetsAddE,
}

func runTargetsAddE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Error: specify the target to add")
        }</span>

        <span class="cov8" title="1">result := getAutoGitOpsConfigMap()

        if result != nil </span><span class="cov8" title="1">{
                t := result["targets"]

                var nt []interface{}

                found := false

                if t != nil </span><span class="cov8" title="1">{
                        for _, v := range t.([]interface{}) </span><span class="cov8" title="1">{
                                nt = append(nt, v)

                                if v == args[0] </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        nt = append(nt, args[0])
                }</span>

                <span class="cov8" title="1">result["targets"] = nt

                saveAutoGitOpsConfig(result)

                fmt.Println(nt)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// ClearCmd clears the GitOps targets
var ClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear all GitOps targets",
        Args:  argsTargets,
        RunE:  runTargetsClearE,
}

func runTargetsClearE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        result := getAutoGitOpsConfigMap()

        if result != nil </span><span class="cov8" title="1">{
                var nt []interface{}

                result["targets"] = nt

                saveAutoGitOpsConfig(result)

                fmt.Println("targets cleared")

                return nil
        }</span>

        <span class="cov0" title="0">return cfmt.ErrorE("Unable to read targets")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
)

// DeployCmd adds, commits, and deploys the GitOps targets to the repo
var DeployCmd = &amp;cobra.Command{
        Use:   "deploy",
        Short: "Deploy to the target stores",
        Args:  argsTargets,
        RunE:  runTargetsDeployE,
}

// run targets deploy cmd
func runTargetsDeployE(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // build the commit message from app name
        app, _ := os.Getwd()
        app = filepath.Base(app)

        // make sure repo is up-to-date
        if err := boa.ShellExecE("git pull"); err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("git pull failed")
                return nil
        }</span>

        // make sure the repo is up to date
        <span class="cov0" title="0">res, err := boa.ShellExecOut("git status -s", false)

        if err != nil </span><span class="cov0" title="0">{
                return cfmt.ErrorE(err)
        }</span>

        <span class="cov0" title="0">if res != "" </span><span class="cov0" title="0">{
                // commit and push
                commit := "git commit -am 'Secure Build: " + app + "'"
                if err := boa.ShellExecE(commit); err != nil </span><span class="cov0" title="0">{
                        cfmt.ErrorE("git commit failed")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if err := boa.ShellExecE("git push"); err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("git push failed")
                return nil
        }</span>

        <span class="cov0" title="0">cfmt.Info("updated " + app)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// ListCmd lists the GitOps targets
var ListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List current targets",
        Args:  argsTargets,
        RunE:  runTargetsListE,
}

func runTargetsListE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        result := getAutoGitOpsConfigMap()

        if result != nil </span><span class="cov8" title="1">{
                if result["targets"] == nil </span><span class="cov0" title="0">{
                        cfmt.Info("targets is empty")
                }</span> else<span class="cov8" title="1"> {
                        cfmt.Info("Targets")
                        fmt.Println(result["targets"])
                }</span>
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov0" title="0"> {
                return cfmt.ErrorE("failed to read autogitops.json")
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "fmt"
        "kic/boa/cfmt"

        "github.com/spf13/cobra"
)

// RemoveCmd removes a target from GitOps
var RemoveCmd = &amp;cobra.Command{
        Use:   "remove",
        Short: "Remove a GitOps target",
        Args:  argsTargets,
        RunE:  runTargetsRemoveE,
}

func runTargetsRemoveE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Error: specify the target to remove")
        }</span>

        <span class="cov8" title="1">result := getAutoGitOpsConfigMap()

        if result == nil </span><span class="cov0" title="0">{
                return cfmt.ErrorE("Error: unable to read autogitops.json")
        }</span> else<span class="cov8" title="1"> {
                t := result["targets"]

                if t == nil </span><span class="cov0" title="0">{
                        fmt.Println("targets is empty")
                        return nil
                }</span>

                <span class="cov8" title="1">var nt []interface{}

                for _, v := range t.([]interface{}) </span><span class="cov8" title="1">{
                        if v != args[0] </span><span class="cov8" title="1">{
                                nt = append(nt, v)
                        }</span>
                }

                <span class="cov8" title="1">result["targets"] = nt

                saveAutoGitOpsConfig(result)

                fmt.Println(nt)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package targets

import (
        "encoding/json"
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
)

var (
        AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "config.json")

        // TargetsCmd contains the GitOps targets commands
        TargetsCmd = &amp;cobra.Command{
                Use:   "targets",
                Short: "Manage GitOps targets",
        }
)

func init() <span class="cov8" title="1">{
        TargetsCmd.AddCommand(AddCmd)
        TargetsCmd.AddCommand(ClearCmd)
        TargetsCmd.AddCommand(ListCmd)
        TargetsCmd.AddCommand(DeployCmd)
        TargetsCmd.AddCommand(RemoveCmd)
}</span>

// args validation for targets commands
func argsTargets(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        return checkForConfigFile()
}</span>

// check for the config file
func checkForConfigFile() error <span class="cov8" title="1">{
        // todo - AGO changed the name of the config file and deprecated autogitops.json in favor of config.json
        //        both still work but config.json is the preferred and future only name
        //        change this back once all the fleets are converted

        // try config.json
        AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "config.json")

        if _, err := os.Stat(AutoGitOpsConfigFile); err != nil </span><span class="cov8" title="1">{
                // try autogitops.json (deprecated)
                AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "autogitops.json")

                if _, err := os.Stat(AutoGitOpsConfigFile); err != nil </span><span class="cov8" title="1">{
                        // set back to preferred
                        AutoGitOpsConfigFile = filepath.Join(".", "autogitops", "config.json")
                        return fmt.Errorf("GitOps file not found - please cd to an app with GitOps setup")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// read config file into map
func getAutoGitOpsConfigMap() map[string]interface{} <span class="cov8" title="1">{
        // check for the config file
        if err := checkForConfigFile(); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // make sure the repo is up to date
        <span class="cov8" title="1">boa.ShellExecOut("git pull", false)

        content, err := os.ReadFile(AutoGitOpsConfigFile)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return nil
        }</span>

        <span class="cov8" title="1">txt := string(content)

        var result map[string]interface{}

        err = json.Unmarshal([]byte(txt), &amp;result)

        if err != nil </span><span class="cov0" title="0">{
                cfmt.ErrorE("unmarshal json faile")
                fmt.Println(err)
                return nil
        }</span>

        <span class="cov8" title="1">return result</span>
}

// save config file from map
func saveAutoGitOpsConfig(result map[string]interface{}) <span class="cov8" title="1">{
        // check for the config file
        if err := checkForConfigFile(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if val, err := json.MarshalIndent(result, "", "    "); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error saving:", err)
        }</span> else<span class="cov8" title="1"> {
                os.WriteFile(AutoGitOpsConfigFile, val, 0644)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package test

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
)

var (
        // command line options
        fileIntegration string
        maxErrors       int
        summary         string

        // test-integration command
        IntegrationCmd = &amp;cobra.Command{
                Use:   "integration",
                Short: "Run an integration test on the cluster",
                RunE:  runTestIntegrationE,
        }
)

// add command specific options
func init() <span class="cov8" title="1">{
        //IntegrationCmd.Flags().StringVarP(&amp;fileIntegration, "file", "f", "baseline.json", "Test file to use")
        IntegrationCmd.Flags().IntVarP(&amp;maxErrors, "max-errors", "", 10, "Max validation errors before terminating test")
        IntegrationCmd.Flags().StringVarP(&amp;summary, "summary", "", "None", "Test summary display &lt;None|Tsv|Xml&gt;")
}</span>

// run the test-integration command
func runTestIntegrationE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfmt.Info("Running integration test")

        if sleep &lt; 0 </span><span class="cov0" title="0">{
                sleep = 0
        }</span>

        // get shared options
        <span class="cov8" title="1">params := getTestFlagValues()

        if maxErrors &gt; 0 </span><span class="cov8" title="1">{
                params += fmt.Sprintf(" --max-errors %d", maxErrors)
        }</span>

        <span class="cov8" title="1">if summary != "" </span><span class="cov8" title="1">{
                params += " --summary " + summary
        }</span>

        // add test-integration specific options to command line
        // keep this arg last to override for innerloop test run
        <span class="cov8" title="1">if fileIntegration != "" </span><span class="cov0" title="0">{
                params += " --files " + fileIntegration
        }</span>

        <span class="cov8" title="1">path := filepath.Join(boa.GetBoaCommandPath(), "test-integration")

        // execute the file with "bash -c" if it exists
        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                return boa.ShellExecE(fmt.Sprintf("%s %s", path, params))
        }</span> else<span class="cov0" title="0"> {
                return cfmt.ErrorE(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package test

import (
        "fmt"
        "kic/boa"
        "kic/boa/cfmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
)

var (
        // command line options
        fileLoad   string
        delayStart int
        duration   int
        random     bool

        // test-load command
        LoadCmd = &amp;cobra.Command{
                Use:   "load",
                Short: "Run a load test on the cluster",
                RunE:  runTestLoadE,
        }
)

// add command specific options
func init() <span class="cov8" title="1">{
        LoadCmd.Flags().StringVarP(&amp;fileLoad, "file", "f", "benchmark.json", "Test file to use")
        LoadCmd.Flags().IntVarP(&amp;delayStart, "delay-start", "", 0, "Delay test start (seconds)")
        LoadCmd.Flags().IntVarP(&amp;duration, "duration", "", 30, "Test duration (seconds)")
        LoadCmd.Flags().BoolVarP(&amp;random, "random", "", false, "Randomize tests")
}</span>

// run the test-load command
func runTestLoadE(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfmt.Info("Running load test")

        if sleep &lt; 1 </span><span class="cov0" title="0">{
                sleep = 100
        }</span>

        // get shared options
        <span class="cov8" title="1">params := getTestFlagValues()

        // add test-load specific options to command line
        params += " --run-loop "

        if delayStart &gt; 0 </span><span class="cov8" title="1">{
                params += fmt.Sprintf(" --delay-start %d", delayStart)
        }</span>

        <span class="cov8" title="1">if duration &gt; 0 </span><span class="cov8" title="1">{
                params += fmt.Sprintf(" --duration %d", duration)
        }</span>

        <span class="cov8" title="1">if random </span><span class="cov8" title="1">{
                params += " --random"
        }</span>

        // keep this arg last to override for innerloop test run
        <span class="cov8" title="1">if fileLoad != "" </span><span class="cov8" title="1">{
                params += " --files " + fileLoad
        }</span>

        // build the path to the script
        <span class="cov8" title="1">path := filepath.Join(boa.GetBoaCommandPath(), "test-load")

        // execute the file with "bash -c" if it exists
        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                return boa.ShellExecE(fmt.Sprintf("%s %s", path, params))
        }</span> else<span class="cov0" title="0"> {
                return cfmt.ErrorE(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package test

import (
        "fmt"
        "github.com/spf13/cobra"
)

var (
        // shared options
        dryRun    bool
        logFormat string
        region    string
        sleep     int
        tag       string
        verbose   bool
        zone      string

        // test command
        TestCmd = &amp;cobra.Command{
                Use:   "test",
                Short: "Run cluster tests",
        }
)

// initialize the test command
func init() <span class="cov8" title="1">{
        // add sub-commands
        TestCmd.AddCommand(IntegrationCmd)
        TestCmd.AddCommand(LoadCmd)

        // add common options
        TestCmd.PersistentFlags().BoolVarP(&amp;dryRun, "dry-run", "d", false, "Validate configuration without running")
        TestCmd.PersistentFlags().StringVarP(&amp;logFormat, "log-format", "", "", "Log format &lt;Json|JsonCamel|None|Tsv|TsvMin&gt;")
        TestCmd.PersistentFlags().StringVarP(&amp;region, "region", "", "", "Region deployed to (user defined)")
        TestCmd.PersistentFlags().IntVarP(&amp;sleep, "sleep", "l", 0, "Sleep (ms) between each request")
        TestCmd.PersistentFlags().StringVarP(&amp;tag, "tag", "", "", "Tag for log (user defined)")
        TestCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Show verbose results")
        TestCmd.PersistentFlags().StringVarP(&amp;zone, "zone", "", "", "Zone deployed to (user defined)")
}</span>

// add the shared flags to the command line
func getTestFlagValues() string <span class="cov8" title="1">{
        cmd := ""

        if verbose </span><span class="cov8" title="1">{
                cmd += " --verbose"
        }</span>
        <span class="cov8" title="1">if sleep &gt; 0 </span><span class="cov8" title="1">{
                cmd += fmt.Sprintf(" --sleep %d", sleep)
        }</span>
        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                cmd += " --dry-run"
        }</span>
        <span class="cov8" title="1">if region != "" </span><span class="cov8" title="1">{
                cmd += " --region " + region
        }</span>
        <span class="cov8" title="1">if zone != "" </span><span class="cov8" title="1">{
                cmd += " --zone " + zone
        }</span>
        <span class="cov8" title="1">if tag != "" </span><span class="cov8" title="1">{
                cmd += " --tag " + tag
        }</span>
        <span class="cov8" title="1">if logFormat != "" </span><span class="cov8" title="1">{
                cmd += " --log-format " + logFormat
        }</span>

        <span class="cov8" title="1">return cmd</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright © Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//   See LICENSE in the project root for license information.

package main

import "kic/cmd"

// execute the root command in cmd/root.go
func main() <span class="cov8" title="1">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
